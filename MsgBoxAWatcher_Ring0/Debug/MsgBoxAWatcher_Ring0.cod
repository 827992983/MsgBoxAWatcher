; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	c:\Users\45819\documents\visual studio 2010\Projects\MsgBoxAWatcher\MsgBoxAWatcher_Ring0\MsgBoxAWatcher_Ring0.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_pDevObj
PUBLIC	_g_ApiCallRecordQueue
_BSS	SEGMENT
_g_pDevObj DD	01H DUP (?)
_g_ApiCallRecordQueue DB 090H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG28380 DB	'\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, '\', 00H, 'M', 00H, 's', 00H, 'g', 00H, 'B', 00H, 'o'
	DB	00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a', 00H, 't', 00H, 'c', 00H
	DB	'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 00H, 00H
$SG28383 DB	0b4H, 0b4H, 0bdH, 0a8H, 0c9H, 0e8H, 0b1H, 0b8H, 0caH, 0a7H
	DB	0b0H, 0dcH, '.', 0aH, 00H
	ORG $+1
$SG28384 DB	'\', 00H, '?', 00H, '?', 00H, '\', 00H, 'M', 00H, 's', 00H
	DB	'g', 00H, 'B', 00H, 'o', 00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'n'
	DB	00H, 'k', 00H, 00H, 00H
$SG28394 DB	'\', 00H, '?', 00H, '?', 00H, '\', 00H, 'M', 00H, 's', 00H
	DB	'g', 00H, 'B', 00H, 'o', 00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'n'
	DB	00H, 'k', 00H, 00H, 00H
$SG28395 DB	0c7H, 0fdH, 0b6H, 0afH, 0d0H, 0b6H, 0d4H, 0d8H, 0b3H, 0c9H
	DB	0b9H, 0a6H, 0aH, 00H
	ORG $+2
$SG28459 DB	'n', 00H, 't', 00H, 'o', 00H, 's', 00H, 'k', 00H, 'r', 00H
	DB	'n', 00H, 'l', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
_DATA	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_IrpDeviceControlProc@8
PUBLIC	_IrpCloseProc@8
PUBLIC	_IrpCreateProc@8
PUBLIC	_InitApiCallQueue@4
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_memset:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
; Function compile flags: /Odtp
; File c:\users\45819\documents\visual studio 2010\projects\msgboxawatcher\msgboxawatcher_ring0\msgboxawatcher_ring0.c
_TEXT	SEGMENT
_pDeviceObj$ = -28					; size = 4
_status$ = -24						; size = 4
_DeviceName$ = -20					; size = 8
_SymbolicLinkName$ = -12				; size = 8
_uIndex$ = -4						; size = 4
_pDriver$ = 8						; size = 4
_RegPath$ = 12						; size = 4
_DriverEntry@8 PROC

; 79   : NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 80   : 	NTSTATUS status;
; 81   : 	ULONG uIndex = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _uIndex$[ebp], 0

; 82   : 	PDEVICE_OBJECT pDeviceObj = NULL; // 设备对象指针

  0000d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pDeviceObj$[ebp], 0

; 83   : 	UNICODE_STRING DeviceName; // 设备名，0环用
; 84   : 	UNICODE_STRING SymbolicLinkName; // 符号链接名，3环用
; 85   : 
; 86   : 	// 初始化调用记录队列
; 87   : 	InitApiCallQueue(&g_ApiCallRecordQueue);

  00014	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  00019	e8 00 00 00 00	 call	 _InitApiCallQueue@4

; 88   : 
; 89   : 	// 创建设备名称
; 90   : 	RtlInitUnicodeString(&DeviceName,DEVICE_NAME);

  0001e	68 00 00 00 00	 push	 OFFSET $SG28380
  00023	8d 45 ec	 lea	 eax, DWORD PTR _DeviceName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 91   : 	// 创建设备	
; 92   : 	status = IoCreateDevice(pDriver,DeviceExtendSize,&DeviceName,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,FALSE,&pDeviceObj);

  0002d	8d 4d e4	 lea	 ecx, DWORD PTR _pDeviceObj$[ebp]
  00030	51		 push	 ecx
  00031	6a 00		 push	 0
  00033	68 00 01 00 00	 push	 256			; 00000100H
  00038	6a 22		 push	 34			; 00000022H
  0003a	8d 55 ec	 lea	 edx, DWORD PTR _DeviceName$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 10 00 00	 push	 4096			; 00001000H
  00043	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  0004d	89 45 e8	 mov	 DWORD PTR _status$[ebp], eax

; 93   : 	if (status != STATUS_SUCCESS)

  00050	83 7d e8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00054	74 1c		 je	 SHORT $LN1@DriverEntr

; 94   : 	{
; 95   : 		IoDeleteDevice(pDeviceObj);

  00056	8b 4d e4	 mov	 ecx, DWORD PTR _pDeviceObj$[ebp]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 96   : 		DbgPrint("创建设备失败.\n");

  00060	68 00 00 00 00	 push	 OFFSET $SG28383
  00065	e8 00 00 00 00	 call	 _DbgPrint
  0006a	83 c4 04	 add	 esp, 4

; 97   : 		return status;

  0006d	8b 45 e8	 mov	 eax, DWORD PTR _status$[ebp]
  00070	eb 75		 jmp	 SHORT $LN2@DriverEntr
$LN1@DriverEntr:

; 98   : 	}
; 99   : 	// 全局变量依赖于设备扩展内存
; 100  : 	// 初始化全局设备指针
; 101  : 	g_pDevObj = pDeviceObj;	

  00072	8b 55 e4	 mov	 edx, DWORD PTR _pDeviceObj$[ebp]
  00075	89 15 00 00 00
	00		 mov	 DWORD PTR _g_pDevObj, edx

; 102  : 	// 初始化设备扩展数据
; 103  : 	memset(pDeviceObj->DeviceExtension,0,DeviceExtendSize);

  0007b	68 00 10 00 00	 push	 4096			; 00001000H
  00080	6a 00		 push	 0
  00082	8b 45 e4	 mov	 eax, DWORD PTR _pDeviceObj$[ebp]
  00085	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _memset
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  : 	//DbgPrint("创建设备成功.\n");
; 105  : 	// 设置交互数据的方式
; 106  : 	pDeviceObj->Flags |= DO_BUFFERED_IO;

  00091	8b 55 e4	 mov	 edx, DWORD PTR _pDeviceObj$[ebp]
  00094	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00097	83 c8 04	 or	 eax, 4
  0009a	8b 4d e4	 mov	 ecx, DWORD PTR _pDeviceObj$[ebp]
  0009d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 107  : 	// 创建符号链接
; 108  : 	RtlInitUnicodeString(&SymbolicLinkName, DRIVER_LINK);

  000a0	68 00 00 00 00	 push	 OFFSET $SG28384
  000a5	8d 55 f4	 lea	 edx, DWORD PTR _SymbolicLinkName$[ebp]
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 109  : 	IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);

  000af	8d 45 ec	 lea	 eax, DWORD PTR _DeviceName$[ebp]
  000b2	50		 push	 eax
  000b3	8d 4d f4	 lea	 ecx, DWORD PTR _SymbolicLinkName$[ebp]
  000b6	51		 push	 ecx
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 110  : 	// 设置分发函数
; 111  : 	pDriver->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;

  000bd	8b 55 08	 mov	 edx, DWORD PTR _pDriver$[ebp]
  000c0	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _IrpCreateProc@8

; 112  : 	pDriver->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  000ca	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _IrpCloseProc@8

; 113  : 	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  000d4	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], OFFSET _IrpDeviceControlProc@8

; 114  : 
; 115  : 	// 设置卸载函数
; 116  : 	pDriver->DriverUnload = DriverUnload;

  000db	8b 55 08	 mov	 edx, DWORD PTR _pDriver$[ebp]
  000de	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _DriverUnload@4

; 117  : 	return STATUS_SUCCESS;

  000e5	33 c0		 xor	 eax, eax
$LN2@DriverEntr:

; 118  : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
_TEXT	ENDS
PUBLIC	_FreeApiCallQueue@4
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_SymbolicLinkName$ = -8					; size = 8
_pDriver$ = 8						; size = 4
_DriverUnload@4 PROC

; 122  : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 08	 sub	 esp, 8

; 123  : 	UNICODE_STRING SymbolicLinkName;
; 124  : 	// 删除GDT表项中的调用门
; 125  : 	memset((PVOID)((PUINT32)(pDriver->DeviceObject->DeviceExtension))[0],0,8);

  000f6	6a 08		 push	 8
  000f8	6a 00		 push	 0
  000fa	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  000fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00100	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00103	8b 02		 mov	 eax, DWORD PTR [edx]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 126  : 	// 删除IDT表中的中断门
; 127  : 	memset((PVOID)(((PUINT32)(pDriver->DeviceObject->DeviceExtension))[1]),0,8);

  0010e	6a 08		 push	 8
  00110	6a 00		 push	 0
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  00115	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00118	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0011b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _memset
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 	// 释放队列内存
; 129  : 	//DbgPrint("队列长度：%d\n", GetCountApiCallQueue(&g_ApiCallRecordQueue));
; 130  : 	FreeApiCallQueue(&g_ApiCallRecordQueue);

  00127	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  0012c	e8 00 00 00 00	 call	 _FreeApiCallQueue@4

; 131  : 	//DbgPrint("队列长度：%d\n", GetCountApiCallQueue(&g_ApiCallRecordQueue));
; 132  : 	// 删除符号链接，删除设备
; 133  : 	RtlInitUnicodeString(&SymbolicLinkName, DRIVER_LINK);

  00131	68 00 00 00 00	 push	 OFFSET $SG28394
  00136	8d 55 f8	 lea	 edx, DWORD PTR _SymbolicLinkName$[ebp]
  00139	52		 push	 edx
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 134  : 	IoDeleteSymbolicLink(&SymbolicLinkName);

  00140	8d 45 f8	 lea	 eax, DWORD PTR _SymbolicLinkName$[ebp]
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 135  : 	IoDeleteDevice(pDriver->DeviceObject);

  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  0014d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00150	52		 push	 edx
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 136  : 	DbgPrint("驱动卸载成功\n");

  00157	68 00 00 00 00	 push	 OFFSET $SG28395
  0015c	e8 00 00 00 00	 call	 _DbgPrint
  00161	83 c4 04	 add	 esp, 4

; 137  : }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 04 00	 ret	 4
_DriverUnload@4 ENDP
_TEXT	ENDS
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpCreateProc@8 PROC

; 142  : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp

; 143  : 	//DbgPrint("应用层连接设备.\n");
; 144  : 	// 返回状态如果不设置，Ring3返回值是失败
; 145  : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

  00173	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  00176	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 146  : 	pIrp->IoStatus.Information = 0;

  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  00180	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 147  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  00187	32 d2		 xor	 dl, dl
  00189	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 148  : 	return STATUS_SUCCESS;

  00192	33 c0		 xor	 eax, eax

; 149  : }

  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
_IrpCreateProc@8 ENDP
; Function compile flags: /Odtp
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpCloseProc@8 PROC

; 153  : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp

; 154  : 	//DbgPrint("应用层断开连接设备.\n");
; 155  : 	// 返回状态如果不设置，Ring3返回值是失败
; 156  : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001a6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 157  : 	pIrp->IoStatus.Information = 0;

  001ad	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  001b0	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 158  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  001b7	32 d2		 xor	 dl, dl
  001b9	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 159  : 	return STATUS_SUCCESS;

  001c2	33 c0		 xor	 eax, eax

; 160  : }

  001c4	5d		 pop	 ebp
  001c5	c2 08 00	 ret	 8
_IrpCloseProc@8 ENDP
_TEXT	ENDS
PUBLIC	_PopApiCallQueue@8
PUBLIC	_SetIntGate@4
PUBLIC	_User32ApiSpyNaked@0
PUBLIC	_SetCallGate@8
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv70 = -44						; size = 4
_record$28439 = -40					; size = 4
_IntGateNum$28434 = -36					; size = 2
_nParam$28428 = -32					; size = 4
_pFunction$28427 = -28					; size = 4
_uIoControlCode$ = -24					; size = 4
_status$ = -20						; size = 4
_pIoBuffer$ = -16					; size = 4
_pIrpStack$ = -12					; size = 4
_uInLength$ = -8					; size = 4
_uOutLength$ = -4					; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpDeviceControlProc@8 PROC

; 164  : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 165  : 	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

  001d6	c7 45 ec 10 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741808 ; c0000010H

; 166  : 	PIO_STACK_LOCATION pIrpStack;
; 167  : 	ULONG uIoControlCode;
; 168  : 	PVOID pIoBuffer;
; 169  : 	ULONG uInLength;
; 170  : 	ULONG uOutLength;
; 171  : 
; 172  : 	// 获取IRP数据
; 173  : 	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  001e6	89 45 f4	 mov	 DWORD PTR _pIrpStack$[ebp], eax

; 174  : 	// 获取控制码
; 175  : 	uIoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

  001e9	8b 4d f4	 mov	 ecx, DWORD PTR _pIrpStack$[ebp]
  001ec	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001ef	89 55 e8	 mov	 DWORD PTR _uIoControlCode$[ebp], edx

; 176  : 	// 获取缓冲区地址（输入输出是同一个）
; 177  : 	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

  001f2	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001f5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001f8	89 4d f0	 mov	 DWORD PTR _pIoBuffer$[ebp], ecx

; 178  : 	// Ring3 发送数据的长度
; 179  : 	uInLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

  001fb	8b 55 f4	 mov	 edx, DWORD PTR _pIrpStack$[ebp]
  001fe	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00201	89 45 f8	 mov	 DWORD PTR _uInLength$[ebp], eax

; 180  : 	// Ring0 发送数据的长度
; 181  : 	uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  00204	8b 4d f4	 mov	 ecx, DWORD PTR _pIrpStack$[ebp]
  00207	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0020a	89 55 fc	 mov	 DWORD PTR _uOutLength$[ebp], edx

; 182  : 
; 183  : 	switch (uIoControlCode)

  0020d	8b 45 e8	 mov	 eax, DWORD PTR _uIoControlCode$[ebp]
  00210	89 45 d4	 mov	 DWORD PTR tv70[ebp], eax
  00213	81 7d d4 00 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236416 ; 00222000H
  0021a	74 17		 je	 SHORT $LN5@IrpDeviceC
  0021c	81 7d d4 04 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236420 ; 00222004H
  00223	74 45		 je	 SHORT $LN4@IrpDeviceC
  00225	81 7d d4 08 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236424 ; 00222008H
  0022c	74 67		 je	 SHORT $LN3@IrpDeviceC
  0022e	e9 b6 00 00 00	 jmp	 $LN6@IrpDeviceC
$LN5@IrpDeviceC:

; 184  : 	{
; 185  : 	case OPER_CALL_GATE_R0:
; 186  : 		{
; 187  : 			UINT32 pFunction; // 3环函数指针
; 188  : 			UINT32 nParam; // 参数个数
; 189  : 			// 给3环传进来的函数指针设置一个调用门
; 190  : 			pFunction = ((PUINT32)pIoBuffer)[0];

  00233	8b 4d f0	 mov	 ecx, DWORD PTR _pIoBuffer$[ebp]
  00236	8b 11		 mov	 edx, DWORD PTR [ecx]
  00238	89 55 e4	 mov	 DWORD PTR _pFunction$28427[ebp], edx

; 191  : 			nParam = ((PUINT32)pIoBuffer)[1];

  0023b	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  0023e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00241	89 4d e0	 mov	 DWORD PTR _nParam$28428[ebp], ecx

; 192  : 			// 设置状态，返回数据
; 193  : 			((PUSHORT)pIoBuffer)[0] = SetCallGate(pFunction, nParam); // 返回调用门选择子

  00244	8b 55 e0	 mov	 edx, DWORD PTR _nParam$28428[ebp]
  00247	52		 push	 edx
  00248	8b 45 e4	 mov	 eax, DWORD PTR _pFunction$28427[ebp]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _SetCallGate@8
  00251	8b 4d f0	 mov	 ecx, DWORD PTR _pIoBuffer$[ebp]
  00254	66 89 01	 mov	 WORD PTR [ecx], ax

; 194  : 			pIrp->IoStatus.Information = 2; // 返回给3环的数据量

  00257	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  0025a	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 195  : 			status = STATUS_SUCCESS;

  00261	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 196  : 			break;

  00268	eb 7f		 jmp	 SHORT $LN6@IrpDeviceC
$LN4@IrpDeviceC:

; 197  : 		}
; 198  : 	case OPER_HOOK:
; 199  : 		{
; 200  : 			// 返回给3环的中断号，3环根据中断号HOOK API
; 201  : 			USHORT IntGateNum;
; 202  : 			// 构造提权中断门
; 203  : 			IntGateNum = SetIntGate((UINT32)User32ApiSpyNaked);

  0026a	68 00 00 00 00	 push	 OFFSET _User32ApiSpyNaked@0
  0026f	e8 00 00 00 00	 call	 _SetIntGate@4
  00274	66 89 45 dc	 mov	 WORD PTR _IntGateNum$28434[ebp], ax

; 204  : 			// 返回中断号
; 205  : 			*(PUSHORT)pIoBuffer = IntGateNum;

  00278	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  0027b	66 8b 4d dc	 mov	 cx, WORD PTR _IntGateNum$28434[ebp]
  0027f	66 89 08	 mov	 WORD PTR [eax], cx

; 206  : 			// 设置状态，返回数据
; 207  : 			pIrp->IoStatus.Information = 2; // 返回给3环的数据量

  00282	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  00285	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 208  : 			status = STATUS_SUCCESS;

  0028c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 209  : 			break;

  00293	eb 54		 jmp	 SHORT $LN6@IrpDeviceC
$LN3@IrpDeviceC:

; 210  : 		}
; 211  : 	case OPER_GET_APICALLRECORD:
; 212  : 		{
; 213  : 			PAPICALLRECORD record = NULL;

  00295	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _record$28439[ebp], 0

; 214  : 			PopApiCallQueue(&g_ApiCallRecordQueue, &record);

  0029c	8d 45 d8	 lea	 eax, DWORD PTR _record$28439[ebp]
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  002a5	e8 00 00 00 00	 call	 _PopApiCallQueue@8

; 215  : 			if (record == NULL)

  002aa	83 7d d8 00	 cmp	 DWORD PTR _record$28439[ebp], 0
  002ae	75 13		 jne	 SHORT $LN2@IrpDeviceC

; 216  : 			{
; 217  : 				// 设置状态，返回数据
; 218  : 				pIrp->IoStatus.Information = 0; // 返回给3环的数据量

  002b0	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002b3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 219  : 				status = STATUS_SUCCESS;

  002ba	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 220  : 			}
; 221  : 			else

  002c1	eb 26		 jmp	 SHORT $LN6@IrpDeviceC
$LN2@IrpDeviceC:

; 222  : 			{
; 223  : 				memcpy(pIoBuffer, record, sizeof(APICALLRECORD));

  002c3	68 90 00 00 00	 push	 144			; 00000090H
  002c8	8b 55 d8	 mov	 edx, DWORD PTR _record$28439[ebp]
  002cb	52		 push	 edx
  002cc	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 _memcpy
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  : 				// 设置状态，返回数据
; 225  : 				pIrp->IoStatus.Information = sizeof(APICALLRECORD); // 返回给3环的数据量

  002d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002db	c7 41 1c 90 00
	00 00		 mov	 DWORD PTR [ecx+28], 144	; 00000090H

; 226  : 				status = STATUS_SUCCESS;

  002e2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0
$LN6@IrpDeviceC:

; 227  : 			}
; 228  : 			break;
; 229  : 		}
; 230  : 	}
; 231  : 
; 232  : 	// 返回状态如果不设置，Ring3返回值是失败
; 233  : 	pIrp->IoStatus.Status = status;

  002e9	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  002ec	8b 45 ec	 mov	 eax, DWORD PTR _status$[ebp]
  002ef	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 234  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  002f2	32 d2		 xor	 dl, dl
  002f4	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 235  : 	return STATUS_SUCCESS;

  002fd	33 c0		 xor	 eax, eax

; 236  : }

  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c2 08 00	 ret	 8
_IrpDeviceControlProc@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@ ; `string'
PUBLIC	??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@ ; `string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@
; File d:\winddk\7600.16385.1\inc\ddk\wdm.h
_DATA	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@
_DATA	SEGMENT
??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@ DB 'D:\WinDD'
	DB	'K\7600.16385.1\inc\ddk\wdm.h', 00H		; `string'
; Function compile flags: /Odtp
_DATA	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00004	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00007	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000b	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0000e	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00012	83 c0 01	 add	 eax, 1
  00015	3b c8		 cmp	 ecx, eax
  00017	7e 20		 jle	 SHORT $LN3@IoGetCurre
  00019	6a 00		 push	 0
  0001b	68 15 5b 00 00	 push	 23317			; 00005b15H
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00037	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  00039	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00043	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_GetKernelBase@12
EXTRN	__imp__RtlCompareUnicodeString@12:PROC
; Function compile flags: /Odtp
; File c:\users\45819\documents\visual studio 2010\projects\msgboxawatcher\msgboxawatcher_ring0\msgboxawatcher_ring0.c
_TEXT	SEGMENT
_pLdte$28464 = -20					; size = 4
_pLdteCur$ = -16					; size = 4
_pLdteHead$ = -12					; size = 4
_usKrnlBaseDllName$ = -8				; size = 8
_driver$ = 8						; size = 4
_pKrnlBase$ = 12					; size = 4
_uKrnlImageSize$ = 16					; size = 4
_GetKernelBase@12 PROC

; 240  : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	83 ec 14	 sub	 esp, 20			; 00000014H

; 241  : 	PLDR_DATA_TABLE_ENTRY pLdteHead; // 内核模块链表头
; 242  : 	PLDR_DATA_TABLE_ENTRY pLdteCur; // 遍历指针
; 243  : 	UNICODE_STRING usKrnlBaseDllName; // 内核模块名
; 244  : 
; 245  : 	RtlInitUnicodeString(&usKrnlBaseDllName,L"ntoskrnl.exe");

  00316	68 00 00 00 00	 push	 OFFSET $SG28459
  0031b	8d 45 f8	 lea	 eax, DWORD PTR _usKrnlBaseDllName$[ebp]
  0031e	50		 push	 eax
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 246  : 	pLdteHead = (PLDR_DATA_TABLE_ENTRY)driver->DriverSection;

  00325	8b 4d 08	 mov	 ecx, DWORD PTR _driver$[ebp]
  00328	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0032b	89 55 f4	 mov	 DWORD PTR _pLdteHead$[ebp], edx

; 247  : 	pLdteCur = pLdteHead;

  0032e	8b 45 f4	 mov	 eax, DWORD PTR _pLdteHead$[ebp]
  00331	89 45 f0	 mov	 DWORD PTR _pLdteCur$[ebp], eax
$LN4@GetKernelB:

; 248  : 	do 
; 249  : 	{
; 250  : 		PLDR_DATA_TABLE_ENTRY pLdte = CONTAINING_RECORD(pLdteCur, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

  00334	8b 4d f0	 mov	 ecx, DWORD PTR _pLdteCur$[ebp]
  00337	89 4d ec	 mov	 DWORD PTR _pLdte$28464[ebp], ecx

; 251  : 		//DbgPrint("DllBase: %p, SizeOfImage: %08X %wZ\n", pLdteCur->DllBase, pLdteCur->SizeOfImage, &(pLdteCur->FullDllName));
; 252  : 		if (RtlCompareUnicodeString(&pLdteCur->BaseDllName, &usKrnlBaseDllName, TRUE) == 0)

  0033a	6a 01		 push	 1
  0033c	8d 55 f8	 lea	 edx, DWORD PTR _usKrnlBaseDllName$[ebp]
  0033f	52		 push	 edx
  00340	8b 45 f0	 mov	 eax, DWORD PTR _pLdteCur$[ebp]
  00343	83 c0 2c	 add	 eax, 44			; 0000002cH
  00346	50		 push	 eax
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlCompareUnicodeString@12
  0034d	85 c0		 test	 eax, eax
  0034f	75 18		 jne	 SHORT $LN1@GetKernelB

; 253  : 		{
; 254  : 			*pKrnlBase = pLdteCur->DllBase;

  00351	8b 4d 0c	 mov	 ecx, DWORD PTR _pKrnlBase$[ebp]
  00354	8b 55 f0	 mov	 edx, DWORD PTR _pLdteCur$[ebp]
  00357	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0035a	89 01		 mov	 DWORD PTR [ecx], eax

; 255  : 			*uKrnlImageSize = pLdteCur->SizeOfImage;

  0035c	8b 4d 10	 mov	 ecx, DWORD PTR _uKrnlImageSize$[ebp]
  0035f	8b 55 f0	 mov	 edx, DWORD PTR _pLdteCur$[ebp]
  00362	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00365	89 01		 mov	 DWORD PTR [ecx], eax

; 256  : 			return;

  00367	eb 10		 jmp	 SHORT $LN5@GetKernelB
$LN1@GetKernelB:

; 257  : 		}
; 258  : 		pLdteCur = (PLDR_DATA_TABLE_ENTRY)pLdteCur->InLoadOrderLinks.Flink;

  00369	8b 4d f0	 mov	 ecx, DWORD PTR _pLdteCur$[ebp]
  0036c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0036e	89 55 f0	 mov	 DWORD PTR _pLdteCur$[ebp], edx

; 259  : 	} while (pLdteHead != pLdteCur);

  00371	8b 45 f4	 mov	 eax, DWORD PTR _pLdteHead$[ebp]
  00374	3b 45 f0	 cmp	 eax, DWORD PTR _pLdteCur$[ebp]
  00377	75 bb		 jne	 SHORT $LN4@GetKernelB
$LN5@GetKernelB:

; 260  : 	return;
; 261  : }

  00379	8b e5		 mov	 esp, ebp
  0037b	5d		 pop	 ebp
  0037c	c2 0c 00	 ret	 12			; 0000000cH
_GetKernelBase@12 ENDP
_TEXT	ENDS
PUBLIC	_MemorySearch@16
EXTRN	__imp__RtlCompareMemory@12:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pCur$ = -4						; size = 4
_bytecode$ = 8						; size = 4
_bytecodeLen$ = 12					; size = 4
_pBeginAddress$ = 16					; size = 4
_pEndAddress$ = 20					; size = 4
_MemorySearch@16 PROC

; 265  : {

  00380	55		 push	 ebp
  00381	8b ec		 mov	 ebp, esp
  00383	51		 push	 ecx

; 266  : 	PVOID pCur = pBeginAddress;

  00384	8b 45 10	 mov	 eax, DWORD PTR _pBeginAddress$[ebp]
  00387	89 45 fc	 mov	 DWORD PTR _pCur$[ebp], eax
$LN3@MemorySear:

; 267  : 	while (pCur != pEndAddress)

  0038a	8b 4d fc	 mov	 ecx, DWORD PTR _pCur$[ebp]
  0038d	3b 4d 14	 cmp	 ecx, DWORD PTR _pEndAddress$[ebp]
  00390	74 27		 je	 SHORT $LN2@MemorySear

; 268  : 	{
; 269  : 		if (RtlCompareMemory(bytecode,pCur,bytecodeLen) == bytecodeLen)

  00392	8b 55 0c	 mov	 edx, DWORD PTR _bytecodeLen$[ebp]
  00395	52		 push	 edx
  00396	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00399	50		 push	 eax
  0039a	8b 4d 08	 mov	 ecx, DWORD PTR _bytecode$[ebp]
  0039d	51		 push	 ecx
  0039e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlCompareMemory@12
  003a4	3b 45 0c	 cmp	 eax, DWORD PTR _bytecodeLen$[ebp]
  003a7	75 05		 jne	 SHORT $LN1@MemorySear

; 270  : 		{
; 271  : 			return pCur;

  003a9	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  003ac	eb 0d		 jmp	 SHORT $LN4@MemorySear
$LN1@MemorySear:

; 272  : 		}
; 273  : 		((UINT32)pCur)++;

  003ae	8b 55 fc	 mov	 edx, DWORD PTR _pCur$[ebp]
  003b1	83 c2 01	 add	 edx, 1
  003b4	89 55 fc	 mov	 DWORD PTR _pCur$[ebp], edx

; 274  : 	}

  003b7	eb d1		 jmp	 SHORT $LN3@MemorySear
$LN2@MemorySear:

; 275  : 	return 0;

  003b9	33 c0		 xor	 eax, eax
$LN4@MemorySear:

; 276  : }

  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c2 10 00	 ret	 16			; 00000010H
_MemorySearch@16 ENDP
; Function compile flags: /Odtp
_IntGateLo$ = -32					; size = 4
_IntGateHi$ = -28					; size = 4
_IdtAddr$ = -24						; size = 4
_IdtLen$ = -20						; size = 4
_i$ = -16						; size = 4
_pPreIntGateAddr$ = -12					; size = 4
_IDT$ = -8						; size = 6
_pFuncion$ = 8						; size = 4
_SetIntGate@4 PROC

; 280  : {	

  003d0	55		 push	 ebp
  003d1	8b ec		 mov	 ebp, esp
  003d3	83 ec 20	 sub	 esp, 32			; 00000020H

; 281  : 	UCHAR IDT[6]; // IDT寄存器
; 282  : 	UINT32 IdtAddr,IdtLen;
; 283  : 	UINT32 IntGateHi = 0,IntGateLo = 0; // 中断门描述符

  003d6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _IntGateHi$[ebp], 0
  003dd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _IntGateLo$[ebp], 0

; 284  : 	UINT32 *pPreIntGateAddr = (UINT32*)g_pDevObj->DeviceExtension + 1;

  003e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pDevObj
  003e9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  003ec	83 c1 04	 add	 ecx, 4
  003ef	89 4d f4	 mov	 DWORD PTR _pPreIntGateAddr$[ebp], ecx

; 285  : 	UINT32 i;
; 286  : 	// 构造中断门描述符
; 287  : 	IntGateLo = ((pFuncion & 0x0000FFFF) | 0x00080000);

  003f2	8b 55 08	 mov	 edx, DWORD PTR _pFuncion$[ebp]
  003f5	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  003fb	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00401	89 55 e0	 mov	 DWORD PTR _IntGateLo$[ebp], edx

; 288  : 	IntGateHi = ((pFuncion & 0xFFFF0000) | 0x0000EE00);

  00404	8b 45 08	 mov	 eax, DWORD PTR _pFuncion$[ebp]
  00407	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  0040c	0d 00 ee 00 00	 or	 eax, 60928		; 0000ee00H
  00411	89 45 e4	 mov	 DWORD PTR _IntGateHi$[ebp], eax

; 289  : 	// 遍历IDT，找无效项
; 290  : 	__asm
; 291  : 	{
; 292  : 		sidt fword ptr IDT;

  00414	0f 01 4d f8	 sidt	 FWORD PTR _IDT$[ebp]

; 293  : 	}
; 294  : 	IdtAddr = *(PULONG)(IDT+2);

  00418	8b 4d fa	 mov	 ecx, DWORD PTR _IDT$[ebp+2]
  0041b	89 4d e8	 mov	 DWORD PTR _IdtAddr$[ebp], ecx

; 295  : 	IdtLen = *(PUSHORT)IDT;

  0041e	0f b7 55 f8	 movzx	 edx, WORD PTR _IDT$[ebp]
  00422	89 55 ec	 mov	 DWORD PTR _IdtLen$[ebp], edx

; 296  : 	// 遍历IDT，找一个P=0的（跳过第一项）
; 297  : 	if ((*pPreIntGateAddr) == 0)

  00425	8b 45 f4	 mov	 eax, DWORD PTR _pPreIntGateAddr$[ebp]
  00428	83 38 00	 cmp	 DWORD PTR [eax], 0
  0042b	75 53		 jne	 SHORT $LN7@SetIntGate

; 298  : 	{				
; 299  : 		for (i = 8; i < IdtLen; i+=8)

  0042d	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
  00434	eb 09		 jmp	 SHORT $LN6@SetIntGate
$LN5@SetIntGate:
  00436	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00439	83 c1 08	 add	 ecx, 8
  0043c	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@SetIntGate:
  0043f	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00442	3b 55 ec	 cmp	 edx, DWORD PTR _IdtLen$[ebp]
  00445	73 37		 jae	 SHORT $LN4@SetIntGate

; 300  : 		{
; 301  : 			if ((((PUINT32)(IdtAddr + i))[1] & 0x00008000) == 0)

  00447	8b 45 e8	 mov	 eax, DWORD PTR _IdtAddr$[ebp]
  0044a	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  0044d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00450	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00456	75 24		 jne	 SHORT $LN3@SetIntGate

; 302  : 			{
; 303  : 				// P=0，此处GDT表项无效，可以使用
; 304  : 				((PUINT32)(IdtAddr + i))[0] = IntGateLo;

  00458	8b 55 e8	 mov	 edx, DWORD PTR _IdtAddr$[ebp]
  0045b	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  0045e	8b 45 e0	 mov	 eax, DWORD PTR _IntGateLo$[ebp]
  00461	89 02		 mov	 DWORD PTR [edx], eax

; 305  : 				((PUINT32)(IdtAddr + i))[1] = IntGateHi;

  00463	8b 4d e8	 mov	 ecx, DWORD PTR _IdtAddr$[ebp]
  00466	03 4d f0	 add	 ecx, DWORD PTR _i$[ebp]
  00469	8b 55 e4	 mov	 edx, DWORD PTR _IntGateHi$[ebp]
  0046c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 306  : 				(*pPreIntGateAddr) = IdtAddr + i;				

  0046f	8b 45 e8	 mov	 eax, DWORD PTR _IdtAddr$[ebp]
  00472	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  00475	8b 4d f4	 mov	 ecx, DWORD PTR _pPreIntGateAddr$[ebp]
  00478	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 				break;

  0047a	eb 02		 jmp	 SHORT $LN4@SetIntGate
$LN3@SetIntGate:

; 308  : 			}
; 309  : 		}

  0047c	eb b8		 jmp	 SHORT $LN5@SetIntGate
$LN4@SetIntGate:

; 310  : 	}
; 311  : 	else

  0047e	eb 15		 jmp	 SHORT $LN2@SetIntGate
$LN7@SetIntGate:

; 312  : 	{
; 313  : 		((PUINT32)(*pPreIntGateAddr))[0] = IntGateLo;

  00480	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  00483	8b 02		 mov	 eax, DWORD PTR [edx]
  00485	8b 4d e0	 mov	 ecx, DWORD PTR _IntGateLo$[ebp]
  00488	89 08		 mov	 DWORD PTR [eax], ecx

; 314  : 		((PUINT32)(*pPreIntGateAddr))[1] = IntGateHi;

  0048a	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  0048d	8b 02		 mov	 eax, DWORD PTR [edx]
  0048f	8b 4d e4	 mov	 ecx, DWORD PTR _IntGateHi$[ebp]
  00492	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@SetIntGate:

; 315  : 	}
; 316  : 
; 317  : 	//DbgPrint("*pPreIntGateAddr: %p.\n", *pPreIntGateAddr);
; 318  : 	//DbgPrint("INT %02X\n", (USHORT)((*pPreIntGateAddr - IdtAddr) / 8));
; 319  : 	if (*pPreIntGateAddr == 0) return 0;

  00495	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  00498	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0049b	75 04		 jne	 SHORT $LN1@SetIntGate
  0049d	33 c0		 xor	 eax, eax
  0049f	eb 0b		 jmp	 SHORT $LN8@SetIntGate
$LN1@SetIntGate:

; 320  : 	return (USHORT)((*pPreIntGateAddr - IdtAddr) / 8);

  004a1	8b 45 f4	 mov	 eax, DWORD PTR _pPreIntGateAddr$[ebp]
  004a4	8b 00		 mov	 eax, DWORD PTR [eax]
  004a6	2b 45 e8	 sub	 eax, DWORD PTR _IdtAddr$[ebp]
  004a9	c1 e8 03	 shr	 eax, 3
$LN8@SetIntGate:

; 321  : }

  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c2 04 00	 ret	 4
_SetIntGate@4 ENDP
; Function compile flags: /Odtp
_CallGateLo$ = -32					; size = 4
_pPreCallGateAddr$ = -28				; size = 4
_CallGateHi$ = -24					; size = 4
_GdtLen$ = -20						; size = 4
_GdtAddr$ = -16						; size = 4
_i$ = -12						; size = 4
_GDT$ = -8						; size = 6
_pFunction$ = 8						; size = 4
_nParam$ = 12						; size = 4
_SetCallGate@8 PROC

; 325  : {	

  004c0	55		 push	 ebp
  004c1	8b ec		 mov	 ebp, esp
  004c3	83 ec 20	 sub	 esp, 32			; 00000020H

; 326  : 	UINT32 CallGateHi = 0,CallGateLo = 0; // 调用门描述符

  004c6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _CallGateHi$[ebp], 0
  004cd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _CallGateLo$[ebp], 0

; 327  : 	UCHAR GDT[6]; // GDT寄存器
; 328  : 	UINT32 GdtAddr,GdtLen;
; 329  : 	UINT32 i;
; 330  : 	UINT32 *pPreCallGateAddr = (UINT32*)g_pDevObj->DeviceExtension;

  004d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pDevObj
  004d9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  004dc	89 4d e4	 mov	 DWORD PTR _pPreCallGateAddr$[ebp], ecx

; 331  : 
; 332  : 	// 构造调用门
; 333  : 	CallGateHi = (pFunction & 0xFFFF0000);

  004df	8b 55 08	 mov	 edx, DWORD PTR _pFunction$[ebp]
  004e2	81 e2 00 00 ff
	ff		 and	 edx, -65536		; ffff0000H
  004e8	89 55 e8	 mov	 DWORD PTR _CallGateHi$[ebp], edx

; 334  : 	CallGateHi |= 0x0000EC00;

  004eb	8b 45 e8	 mov	 eax, DWORD PTR _CallGateHi$[ebp]
  004ee	0d 00 ec 00 00	 or	 eax, 60416		; 0000ec00H
  004f3	89 45 e8	 mov	 DWORD PTR _CallGateHi$[ebp], eax

; 335  : 	CallGateHi |= nParam;

  004f6	8b 4d e8	 mov	 ecx, DWORD PTR _CallGateHi$[ebp]
  004f9	0b 4d 0c	 or	 ecx, DWORD PTR _nParam$[ebp]
  004fc	89 4d e8	 mov	 DWORD PTR _CallGateHi$[ebp], ecx

; 336  : 	CallGateLo = (pFunction & 0x0000FFFF);

  004ff	8b 55 08	 mov	 edx, DWORD PTR _pFunction$[ebp]
  00502	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00508	89 55 e0	 mov	 DWORD PTR _CallGateLo$[ebp], edx

; 337  : 	CallGateLo |= 0x00080000;

  0050b	8b 45 e0	 mov	 eax, DWORD PTR _CallGateLo$[ebp]
  0050e	0d 00 00 08 00	 or	 eax, 524288		; 00080000H
  00513	89 45 e0	 mov	 DWORD PTR _CallGateLo$[ebp], eax

; 338  : 	// 获取GDT基址和大小
; 339  : 	__asm
; 340  : 	{
; 341  : 		sgdt fword ptr GDT;

  00516	0f 01 45 f8	 sgdt	 FWORD PTR _GDT$[ebp]

; 342  : 	}
; 343  : 	GdtAddr = *(PULONG)(GDT+2);

  0051a	8b 4d fa	 mov	 ecx, DWORD PTR _GDT$[ebp+2]
  0051d	89 4d f0	 mov	 DWORD PTR _GdtAddr$[ebp], ecx

; 344  : 	GdtLen = *(PUSHORT)GDT;

  00520	0f b7 55 f8	 movzx	 edx, WORD PTR _GDT$[ebp]
  00524	89 55 ec	 mov	 DWORD PTR _GdtLen$[ebp], edx

; 345  : 	// 遍历GDT，找一个P=0的（跳过第一项）
; 346  : 	if ((*pPreCallGateAddr) == 0)

  00527	8b 45 e4	 mov	 eax, DWORD PTR _pPreCallGateAddr$[ebp]
  0052a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0052d	75 53		 jne	 SHORT $LN7@SetCallGat

; 347  : 	{				
; 348  : 		for (i = 8; i < GdtLen; i+=8)

  0052f	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
  00536	eb 09		 jmp	 SHORT $LN6@SetCallGat
$LN5@SetCallGat:
  00538	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0053b	83 c1 08	 add	 ecx, 8
  0053e	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@SetCallGat:
  00541	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00544	3b 55 ec	 cmp	 edx, DWORD PTR _GdtLen$[ebp]
  00547	73 37		 jae	 SHORT $LN4@SetCallGat

; 349  : 		{
; 350  : 			//DbgPrint("%p\n",(PUINT32)(GdtAddr + i));
; 351  : 			if ((((PUINT32)(GdtAddr + i))[1] & 0x00008000) == 0)

  00549	8b 45 f0	 mov	 eax, DWORD PTR _GdtAddr$[ebp]
  0054c	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  0054f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00552	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00558	75 24		 jne	 SHORT $LN3@SetCallGat

; 352  : 			{
; 353  : 				// P=0，此处GDT表项无效，可以使用
; 354  : 				((PUINT32)(GdtAddr + i))[0] = CallGateLo;

  0055a	8b 55 f0	 mov	 edx, DWORD PTR _GdtAddr$[ebp]
  0055d	03 55 f4	 add	 edx, DWORD PTR _i$[ebp]
  00560	8b 45 e0	 mov	 eax, DWORD PTR _CallGateLo$[ebp]
  00563	89 02		 mov	 DWORD PTR [edx], eax

; 355  : 				((PUINT32)(GdtAddr + i))[1] = CallGateHi;

  00565	8b 4d f0	 mov	 ecx, DWORD PTR _GdtAddr$[ebp]
  00568	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  0056b	8b 55 e8	 mov	 edx, DWORD PTR _CallGateHi$[ebp]
  0056e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 356  : 				(*pPreCallGateAddr) = GdtAddr + i;

  00571	8b 45 f0	 mov	 eax, DWORD PTR _GdtAddr$[ebp]
  00574	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00577	8b 4d e4	 mov	 ecx, DWORD PTR _pPreCallGateAddr$[ebp]
  0057a	89 01		 mov	 DWORD PTR [ecx], eax

; 357  : 				break;

  0057c	eb 02		 jmp	 SHORT $LN4@SetCallGat
$LN3@SetCallGat:

; 358  : 			}
; 359  : 		}

  0057e	eb b8		 jmp	 SHORT $LN5@SetCallGat
$LN4@SetCallGat:

; 360  : 	}
; 361  : 	else

  00580	eb 15		 jmp	 SHORT $LN2@SetCallGat
$LN7@SetCallGat:

; 362  : 	{
; 363  : 		((PUINT32)(*pPreCallGateAddr))[0] = CallGateLo;

  00582	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  00585	8b 02		 mov	 eax, DWORD PTR [edx]
  00587	8b 4d e0	 mov	 ecx, DWORD PTR _CallGateLo$[ebp]
  0058a	89 08		 mov	 DWORD PTR [eax], ecx

; 364  : 		((PUINT32)(*pPreCallGateAddr))[1] = CallGateHi;

  0058c	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  0058f	8b 02		 mov	 eax, DWORD PTR [edx]
  00591	8b 4d e8	 mov	 ecx, DWORD PTR _CallGateHi$[ebp]
  00594	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@SetCallGat:

; 365  : 	}
; 366  : 	if (*pPreCallGateAddr == 0) return 0;

  00597	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  0059a	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0059d	75 04		 jne	 SHORT $LN1@SetCallGat
  0059f	33 c0		 xor	 eax, eax
  005a1	eb 08		 jmp	 SHORT $LN8@SetCallGat
$LN1@SetCallGat:

; 367  : 	return (USHORT)((*pPreCallGateAddr) - GdtAddr);

  005a3	8b 45 e4	 mov	 eax, DWORD PTR _pPreCallGateAddr$[ebp]
  005a6	8b 00		 mov	 eax, DWORD PTR [eax]
  005a8	2b 45 f0	 sub	 eax, DWORD PTR _GdtAddr$[ebp]
$LN8@SetCallGat:

; 368  : }

  005ab	8b e5		 mov	 esp, ebp
  005ad	5d		 pop	 ebp
  005ae	c2 08 00	 ret	 8
_SetCallGate@8 ENDP
_TEXT	ENDS
PUBLIC	_GetPDE@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_GetPDE@4 PROC

; 372  : {

  005c0	55		 push	 ebp
  005c1	8b ec		 mov	 ebp, esp

; 373  : 	return (UINT32 *)(0xc0600000 + ((addr >> 18) & 0x3ff8));

  005c3	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  005c6	c1 e8 12	 shr	 eax, 18			; 00000012H
  005c9	25 f8 3f 00 00	 and	 eax, 16376		; 00003ff8H
  005ce	2d 00 00 a0 3f	 sub	 eax, 1067450368		; 3fa00000H

; 374  : }

  005d3	5d		 pop	 ebp
  005d4	c2 04 00	 ret	 4
_GetPDE@4 ENDP
_TEXT	ENDS
PUBLIC	_GetPTE@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_GetPTE@4 PROC

; 378  : {

  005e0	55		 push	 ebp
  005e1	8b ec		 mov	 ebp, esp

; 379  : 	return (UINT32 *)(0xc0000000 + ((addr >> 9) & 0x7ffff8));

  005e3	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  005e6	c1 e8 09	 shr	 eax, 9
  005e9	25 f8 ff 7f 00	 and	 eax, 8388600		; 007ffff8H
  005ee	2d 00 00 00 40	 sub	 eax, 1073741824		; 40000000H

; 380  : }

  005f3	5d		 pop	 ebp
  005f4	c2 04 00	 ret	 4
_GetPTE@4 ENDP
_TEXT	ENDS
PUBLIC	_User32ApiSpy@8
; Function compile flags: /Odtp
_TEXT	SEGMENT
_User32ApiSpyNaked@0 PROC

; 386  : 	__asm
; 387  : 	{
; 388  : 		pushad; // esp - 0x20

  00600	60		 pushad

; 389  : 		pushfd; // esp - 0x04

  00601	9c		 pushfd

; 390  : 
; 391  : 		mov eax,[esp + 0x24];		

  00602	8b 44 24 24	 mov	 eax, DWORD PTR [esp+36]

; 392  : 		mov ecx,[esp + 0x24 + 0x0C];

  00606	8b 4c 24 30	 mov	 ecx, DWORD PTR [esp+48]

; 393  : 		push eax; // EIP3

  0060a	50		 push	 eax

; 394  : 		push ecx; // ESP3

  0060b	51		 push	 ecx

; 395  : 		call User32ApiSpy;

  0060c	e8 00 00 00 00	 call	 _User32ApiSpy@8

; 396  : 
; 397  : 		popfd;

  00611	9d		 popfd

; 398  : 		popad;

  00612	61		 popad

; 399  : 		iretd;

  00613	cf		 iretd
_User32ApiSpyNaked@0 ENDP
_TEXT	ENDS
PUBLIC	_PushApiCallQueue@8
EXTRN	__imp__ExAllocatePool@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pApiCallRecord$28556 = -8				; size = 4
_ApiAddress$ = -4					; size = 4
_ESP3$ = 8						; size = 4
_EIP3$ = 12						; size = 4
_User32ApiSpy@8 PROC

; 405  : {

  00620	55		 push	 ebp
  00621	8b ec		 mov	 ebp, esp
  00623	83 ec 08	 sub	 esp, 8

; 406  : 	UINT32 ApiAddress;
; 407  : 	// EIP3-0x02是API的地址
; 408  : 	// ESP3是3环的ESP，可以用来读参数
; 409  : 	__asm push fs;

  00626	0f a0		 push	 fs

; 410  : 	ApiAddress = EIP3 - 2;

  00628	8b 45 0c	 mov	 eax, DWORD PTR _EIP3$[ebp]
  0062b	83 e8 02	 sub	 eax, 2
  0062e	89 45 fc	 mov	 DWORD PTR _ApiAddress$[ebp], eax

; 411  : 	//DbgPrint("ESP3: %08x, API: %08x\n", ESP3, ApiAddress);
; 412  : 	// 判断API地址
; 413  : 	if (ApiAddress == 0x77d507ea)

  00631	81 7d fc ea 07
	d5 77		 cmp	 DWORD PTR _ApiAddress$[ebp], 2010449898 ; 77d507eaH
  00638	75 68		 jne	 SHORT $LN1@User32ApiS

; 414  : 	{
; 415  : 		PAPICALLRECORD pApiCallRecord = NULL;

  0063a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pApiCallRecord$28556[ebp], 0

; 416  : 		// 添加调用记录到队列，监视进程通过IRP消息读取队列
; 417  : 		pApiCallRecord = (PAPICALLRECORD)ExAllocatePool(PagedPool,sizeof(APICALLRECORD));

  00641	68 90 00 00 00	 push	 144			; 00000090H
  00646	6a 01		 push	 1
  00648	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePool@8
  0064e	89 45 f8	 mov	 DWORD PTR _pApiCallRecord$28556[ebp], eax

; 418  : 		pApiCallRecord->nParam = 4;

  00651	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  00654	c7 41 0c 04 00
	00 00		 mov	 DWORD PTR [ecx+12], 4

; 419  : 		pApiCallRecord->pApiAddress = ApiAddress;

  0065b	8b 55 f8	 mov	 edx, DWORD PTR _pApiCallRecord$28556[ebp]
  0065e	8b 45 fc	 mov	 eax, DWORD PTR _ApiAddress$[ebp]
  00661	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 420  : 		pApiCallRecord->Param[0] = ((PUINT32)ESP3)[1];

  00664	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  00667	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  0066a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0066d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 421  : 		pApiCallRecord->Param[1] = ((PUINT32)ESP3)[2];

  00670	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  00673	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  00676	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00679	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 422  : 		pApiCallRecord->Param[2] = ((PUINT32)ESP3)[3];

  0067c	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  0067f	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  00682	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00685	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 423  : 		pApiCallRecord->Param[3] = ((PUINT32)ESP3)[4];

  00688	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  0068b	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  0068e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00691	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 424  : 		PushApiCallQueue(&g_ApiCallRecordQueue, (PAPICALLRECORD)pApiCallRecord);

  00694	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28556[ebp]
  00697	51		 push	 ecx
  00698	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  0069d	e8 00 00 00 00	 call	 _PushApiCallQueue@8
$LN1@User32ApiS:

; 425  : 	}
; 426  : 	__asm pop fs;

  006a2	0f a1		 pop	 fs

; 427  : }

  006a4	8b e5		 mov	 esp, ebp
  006a6	5d		 pop	 ebp
  006a7	c2 08 00	 ret	 8
_User32ApiSpy@8 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_InitApiCallQueue@4 PROC

; 431  : {

  006b0	55		 push	 ebp
  006b1	8b ec		 mov	 ebp, esp

; 432  : 	QueueHead->ApiCallRecordList.Flink = QueueHead->ApiCallRecordList.Blink = (PLIST_ENTRY)QueueHead;

  006b3	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  006b6	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  006b9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  006bc	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  006bf	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  006c2	89 02		 mov	 DWORD PTR [edx], eax

; 433  : }

  006c4	5d		 pop	 ebp
  006c5	c2 04 00	 ret	 4
_InitApiCallQueue@4 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_pApiCallRecord$ = 12					; size = 4
_PushApiCallQueue@8 PROC

; 437  : {

  006d0	55		 push	 ebp
  006d1	8b ec		 mov	 ebp, esp

; 438  : 	// 原队尾的下一个节点指向新队尾
; 439  : 	QueueHead->ApiCallRecordList.Blink->Flink = (PLIST_ENTRY)pApiCallRecord;

  006d3	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  006d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006d9	8b 55 0c	 mov	 edx, DWORD PTR _pApiCallRecord$[ebp]
  006dc	89 11		 mov	 DWORD PTR [ecx], edx

; 440  : 	// 新队尾的上一个节点指向原队尾
; 441  : 	pApiCallRecord->ApiCallRecordList.Blink = QueueHead->ApiCallRecordList.Blink;

  006de	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  006e1	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  006e4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  006e7	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 442  : 	// 新队尾的下一个节点指向队列头
; 443  : 	pApiCallRecord->ApiCallRecordList.Flink = (PLIST_ENTRY)QueueHead;

  006ea	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  006ed	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  006f0	89 08		 mov	 DWORD PTR [eax], ecx

; 444  : 	// 队列头的上一个节点指向新队尾
; 445  : 	QueueHead->ApiCallRecordList.Blink = (PLIST_ENTRY)pApiCallRecord;	

  006f2	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  006f5	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  006f8	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 446  : }

  006fb	5d		 pop	 ebp
  006fc	c2 08 00	 ret	 8
_PushApiCallQueue@8 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_pApiCallRecord$ = 12					; size = 4
_PopApiCallQueue@8 PROC

; 450  : {

  00700	55		 push	 ebp
  00701	8b ec		 mov	 ebp, esp

; 451  : 	// 记录要弹出的节点
; 452  : 	*pApiCallRecord = (PAPICALLRECORD)(QueueHead->ApiCallRecordList.Flink);

  00703	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00706	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  00709	8b 11		 mov	 edx, DWORD PTR [ecx]
  0070b	89 10		 mov	 DWORD PTR [eax], edx

; 453  : 	// 如果队列为空，返回NULL
; 454  : 	if (*pApiCallRecord == &g_ApiCallRecordQueue)

  0070d	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00710	81 38 00 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET _g_ApiCallRecordQueue
  00716	75 09		 jne	 SHORT $LN1@PopApiCall

; 455  : 	{
; 456  : 		*pApiCallRecord = NULL;

  00718	8b 4d 0c	 mov	 ecx, DWORD PTR _pApiCallRecord$[ebp]
  0071b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN1@PopApiCall:

; 457  : 	}
; 458  : 	// 第二个节点的上一个节点指向队首
; 459  : 	QueueHead->ApiCallRecordList.Flink->Flink->Blink = (PLIST_ENTRY)QueueHead;

  00721	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  00724	8b 02		 mov	 eax, DWORD PTR [edx]
  00726	8b 08		 mov	 ecx, DWORD PTR [eax]
  00728	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  0072b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 460  : 	// 队首的下一个节点指向第二个节点
; 461  : 	QueueHead->ApiCallRecordList.Flink = QueueHead->ApiCallRecordList.Flink->Flink;

  0072e	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00731	8b 08		 mov	 ecx, DWORD PTR [eax]
  00733	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  00736	8b 01		 mov	 eax, DWORD PTR [ecx]
  00738	89 02		 mov	 DWORD PTR [edx], eax

; 462  : }

  0073a	5d		 pop	 ebp
  0073b	c2 08 00	 ret	 8
_PopApiCallQueue@8 ENDP
_TEXT	ENDS
PUBLIC	_GetCountApiCallQueue@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pList$ = -8						; size = 4
_cnt$ = -4						; size = 4
_QueueHead$ = 8						; size = 4
_GetCountApiCallQueue@4 PROC

; 466  : {

  00740	55		 push	 ebp
  00741	8b ec		 mov	 ebp, esp
  00743	83 ec 08	 sub	 esp, 8

; 467  : 	UINT32 cnt = 0;

  00746	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0

; 468  : 	PLIST_ENTRY pList = QueueHead->ApiCallRecordList.Flink;

  0074d	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00750	8b 08		 mov	 ecx, DWORD PTR [eax]
  00752	89 4d f8	 mov	 DWORD PTR _pList$[ebp], ecx
$LN2@GetCountAp:

; 469  : 	while (pList != (PLIST_ENTRY)QueueHead)

  00755	8b 55 f8	 mov	 edx, DWORD PTR _pList$[ebp]
  00758	3b 55 08	 cmp	 edx, DWORD PTR _QueueHead$[ebp]
  0075b	74 13		 je	 SHORT $LN1@GetCountAp

; 470  : 	{
; 471  : 		pList = pList->Flink;

  0075d	8b 45 f8	 mov	 eax, DWORD PTR _pList$[ebp]
  00760	8b 08		 mov	 ecx, DWORD PTR [eax]
  00762	89 4d f8	 mov	 DWORD PTR _pList$[ebp], ecx

; 472  : 		cnt++;

  00765	8b 55 fc	 mov	 edx, DWORD PTR _cnt$[ebp]
  00768	83 c2 01	 add	 edx, 1
  0076b	89 55 fc	 mov	 DWORD PTR _cnt$[ebp], edx

; 473  : 	}

  0076e	eb e5		 jmp	 SHORT $LN2@GetCountAp
$LN1@GetCountAp:

; 474  : 	return cnt;

  00770	8b 45 fc	 mov	 eax, DWORD PTR _cnt$[ebp]

; 475  : }

  00773	8b e5		 mov	 esp, ebp
  00775	5d		 pop	 ebp
  00776	c2 04 00	 ret	 4
_GetCountApiCallQueue@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pApiCallRecord$ = -4					; size = 4
_QueueHead$ = 8						; size = 4
_FreeApiCallQueue@4 PROC

; 479  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	51		 push	 ecx
$LN2@FreeApiCal:

; 480  : 	PAPICALLRECORD pApiCallRecord;
; 481  : 	while(QueueHead->ApiCallRecordList.Flink != (PLIST_ENTRY)QueueHead)

  00784	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00787	8b 08		 mov	 ecx, DWORD PTR [eax]
  00789	3b 4d 08	 cmp	 ecx, DWORD PTR _QueueHead$[ebp]
  0078c	74 1b		 je	 SHORT $LN3@FreeApiCal

; 482  : 	{		
; 483  : 		PopApiCallQueue(QueueHead, &pApiCallRecord);

  0078e	8d 55 fc	 lea	 edx, DWORD PTR _pApiCallRecord$[ebp]
  00791	52		 push	 edx
  00792	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00795	50		 push	 eax
  00796	e8 00 00 00 00	 call	 _PopApiCallQueue@8

; 484  : 		ExFreePool(pApiCallRecord);

  0079b	6a 00		 push	 0
  0079d	8b 4d fc	 mov	 ecx, DWORD PTR _pApiCallRecord$[ebp]
  007a0	51		 push	 ecx
  007a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 485  : 	}

  007a7	eb db		 jmp	 SHORT $LN2@FreeApiCal
$LN3@FreeApiCal:

; 486  : }

  007a9	8b e5		 mov	 esp, ebp
  007ab	5d		 pop	 ebp
  007ac	c2 04 00	 ret	 4
_FreeApiCallQueue@4 ENDP
_TEXT	ENDS
END
