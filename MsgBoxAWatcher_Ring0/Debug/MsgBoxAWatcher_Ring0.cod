; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\45819\Documents\Visual Studio 2010\Projects\MsgBoxAWatcher\MsgBoxAWatcher_Ring0\MsgBoxAWatcher_Ring0.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_pDevObj
PUBLIC	_g_ApiCallRecordQueue
_BSS	SEGMENT
_g_pDevObj DD	01H DUP (?)
_g_ApiCallRecordQueue DB 090H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG28364 DB	'\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, '\', 00H, 'M', 00H, 's', 00H, 'g', 00H, 'B', 00H, 'o'
	DB	00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a', 00H, 't', 00H, 'c', 00H
	DB	'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 00H, 00H
$SG28367 DB	0b4H, 0b4H, 0bdH, 0a8H, 0c9H, 0e8H, 0b1H, 0b8H, 0caH, 0a7H
	DB	0b0H, 0dcH, '.', 0aH, 00H
	ORG $+1
$SG28368 DB	'\', 00H, '?', 00H, '?', 00H, '\', 00H, 'M', 00H, 's', 00H
	DB	'g', 00H, 'B', 00H, 'o', 00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'n'
	DB	00H, 'k', 00H, 00H, 00H
$SG28378 DB	'\', 00H, '?', 00H, '?', 00H, '\', 00H, 'M', 00H, 's', 00H
	DB	'g', 00H, 'B', 00H, 'o', 00H, 'x', 00H, 'A', 00H, 'W', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'D', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'n'
	DB	00H, 'k', 00H, 00H, 00H
$SG28379 DB	0c7H, 0fdH, 0b6H, 0afH, 0d0H, 0b6H, 0d4H, 0d8H, 0b3H, 0c9H
	DB	0b9H, 0a6H, 0aH, 00H
_DATA	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_IrpDeviceControlProc@8
PUBLIC	_IrpCloseProc@8
PUBLIC	_IrpCreateProc@8
PUBLIC	_InitApiCallQueue@4
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_memset:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__RtlInitUnicodeString@8:PROC
; Function compile flags: /Odtp
; File c:\users\45819\documents\visual studio 2010\projects\msgboxawatcher\msgboxawatcher_ring0\msgboxawatcher_ring0.c
_TEXT	SEGMENT
_pDeviceObj$ = -28					; size = 4
_status$ = -24						; size = 4
_DeviceName$ = -20					; size = 8
_SymbolicLinkName$ = -12				; size = 8
_uIndex$ = -4						; size = 4
_pDriver$ = 8						; size = 4
_RegPath$ = 12						; size = 4
_DriverEntry@8 PROC

; 73   : NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 74   : 	NTSTATUS status;
; 75   : 	ULONG uIndex = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _uIndex$[ebp], 0

; 76   : 	PDEVICE_OBJECT pDeviceObj = NULL; // 设备对象指针

  0000d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pDeviceObj$[ebp], 0

; 77   : 	UNICODE_STRING DeviceName; // 设备名，0环用
; 78   : 	UNICODE_STRING SymbolicLinkName; // 符号链接名，3环用
; 79   : 
; 80   : 	// 初始化调用记录队列
; 81   : 	InitApiCallQueue(&g_ApiCallRecordQueue);

  00014	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  00019	e8 00 00 00 00	 call	 _InitApiCallQueue@4

; 82   : 
; 83   : 	// 创建设备名称
; 84   : 	RtlInitUnicodeString(&DeviceName,DEVICE_NAME);

  0001e	68 00 00 00 00	 push	 OFFSET $SG28364
  00023	8d 45 ec	 lea	 eax, DWORD PTR _DeviceName$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 85   : 	// 创建设备	
; 86   : 	status = IoCreateDevice(pDriver,DeviceExtendSize,&DeviceName,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,FALSE,&pDeviceObj);

  0002d	8d 4d e4	 lea	 ecx, DWORD PTR _pDeviceObj$[ebp]
  00030	51		 push	 ecx
  00031	6a 00		 push	 0
  00033	68 00 01 00 00	 push	 256			; 00000100H
  00038	6a 22		 push	 34			; 00000022H
  0003a	8d 55 ec	 lea	 edx, DWORD PTR _DeviceName$[ebp]
  0003d	52		 push	 edx
  0003e	68 00 10 00 00	 push	 4096			; 00001000H
  00043	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  0004d	89 45 e8	 mov	 DWORD PTR _status$[ebp], eax

; 87   : 	if (status != STATUS_SUCCESS)

  00050	83 7d e8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00054	74 1c		 je	 SHORT $LN1@DriverEntr

; 88   : 	{
; 89   : 		IoDeleteDevice(pDeviceObj);

  00056	8b 4d e4	 mov	 ecx, DWORD PTR _pDeviceObj$[ebp]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 90   : 		DbgPrint("创建设备失败.\n");

  00060	68 00 00 00 00	 push	 OFFSET $SG28367
  00065	e8 00 00 00 00	 call	 _DbgPrint
  0006a	83 c4 04	 add	 esp, 4

; 91   : 		return status;

  0006d	8b 45 e8	 mov	 eax, DWORD PTR _status$[ebp]
  00070	eb 75		 jmp	 SHORT $LN2@DriverEntr
$LN1@DriverEntr:

; 92   : 	}
; 93   : 	// 全局变量依赖于设备扩展内存
; 94   : 	// 初始化全局设备指针
; 95   : 	g_pDevObj = pDeviceObj;	

  00072	8b 55 e4	 mov	 edx, DWORD PTR _pDeviceObj$[ebp]
  00075	89 15 00 00 00
	00		 mov	 DWORD PTR _g_pDevObj, edx

; 96   : 	// 初始化设备扩展数据
; 97   : 	memset(pDeviceObj->DeviceExtension,0,DeviceExtendSize);

  0007b	68 00 10 00 00	 push	 4096			; 00001000H
  00080	6a 00		 push	 0
  00082	8b 45 e4	 mov	 eax, DWORD PTR _pDeviceObj$[ebp]
  00085	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _memset
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 98   : 	//DbgPrint("创建设备成功.\n");
; 99   : 	// 设置交互数据的方式
; 100  : 	pDeviceObj->Flags |= DO_BUFFERED_IO;

  00091	8b 55 e4	 mov	 edx, DWORD PTR _pDeviceObj$[ebp]
  00094	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00097	83 c8 04	 or	 eax, 4
  0009a	8b 4d e4	 mov	 ecx, DWORD PTR _pDeviceObj$[ebp]
  0009d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 101  : 	// 创建符号链接
; 102  : 	RtlInitUnicodeString(&SymbolicLinkName, DRIVER_LINK);

  000a0	68 00 00 00 00	 push	 OFFSET $SG28368
  000a5	8d 55 f4	 lea	 edx, DWORD PTR _SymbolicLinkName$[ebp]
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 103  : 	IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);

  000af	8d 45 ec	 lea	 eax, DWORD PTR _DeviceName$[ebp]
  000b2	50		 push	 eax
  000b3	8d 4d f4	 lea	 ecx, DWORD PTR _SymbolicLinkName$[ebp]
  000b6	51		 push	 ecx
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateSymbolicLink@8

; 104  : 	// 设置分发函数
; 105  : 	pDriver->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;

  000bd	8b 55 08	 mov	 edx, DWORD PTR _pDriver$[ebp]
  000c0	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _IrpCreateProc@8

; 106  : 	pDriver->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  000ca	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _IrpCloseProc@8

; 107  : 	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  000d4	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], OFFSET _IrpDeviceControlProc@8

; 108  : 
; 109  : 	// 设置卸载函数
; 110  : 	pDriver->DriverUnload = DriverUnload;

  000db	8b 55 08	 mov	 edx, DWORD PTR _pDriver$[ebp]
  000de	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _DriverUnload@4

; 111  : 	return STATUS_SUCCESS;

  000e5	33 c0		 xor	 eax, eax
$LN2@DriverEntr:

; 112  : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
_TEXT	ENDS
PUBLIC	_FreeApiCallQueue@4
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_SymbolicLinkName$ = -8					; size = 8
_pDriver$ = 8						; size = 4
_DriverUnload@4 PROC

; 116  : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 08	 sub	 esp, 8

; 117  : 	UNICODE_STRING SymbolicLinkName;
; 118  : 	// 删除GDT表项中的调用门
; 119  : 	memset((PVOID)((PUINT32)(pDriver->DeviceObject->DeviceExtension))[0],0,8);

  000f6	6a 08		 push	 8
  000f8	6a 00		 push	 0
  000fa	8b 45 08	 mov	 eax, DWORD PTR _pDriver$[ebp]
  000fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00100	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00103	8b 02		 mov	 eax, DWORD PTR [edx]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  : 	// 删除IDT表中的中断门
; 121  : 	memset((PVOID)(((PUINT32)(pDriver->DeviceObject->DeviceExtension))[1]),0,8);

  0010e	6a 08		 push	 8
  00110	6a 00		 push	 0
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  00115	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00118	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0011b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _memset
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 	// 释放队列内存
; 123  : 	//DbgPrint("队列长度：%d\n", GetCountApiCallQueue(&g_ApiCallRecordQueue));
; 124  : 	FreeApiCallQueue(&g_ApiCallRecordQueue);

  00127	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  0012c	e8 00 00 00 00	 call	 _FreeApiCallQueue@4

; 125  : 	//DbgPrint("队列长度：%d\n", GetCountApiCallQueue(&g_ApiCallRecordQueue));
; 126  : 	// 删除符号链接，删除设备
; 127  : 	RtlInitUnicodeString(&SymbolicLinkName, DRIVER_LINK);

  00131	68 00 00 00 00	 push	 OFFSET $SG28378
  00136	8d 55 f8	 lea	 edx, DWORD PTR _SymbolicLinkName$[ebp]
  00139	52		 push	 edx
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 128  : 	IoDeleteSymbolicLink(&SymbolicLinkName);

  00140	8d 45 f8	 lea	 eax, DWORD PTR _SymbolicLinkName$[ebp]
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteSymbolicLink@4

; 129  : 	IoDeleteDevice(pDriver->DeviceObject);

  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _pDriver$[ebp]
  0014d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00150	52		 push	 edx
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 130  : 	DbgPrint("驱动卸载成功\n");

  00157	68 00 00 00 00	 push	 OFFSET $SG28379
  0015c	e8 00 00 00 00	 call	 _DbgPrint
  00161	83 c4 04	 add	 esp, 4

; 131  : }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 04 00	 ret	 4
_DriverUnload@4 ENDP
_TEXT	ENDS
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpCreateProc@8 PROC

; 136  : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp

; 137  : 	//DbgPrint("应用层连接设备.\n");
; 138  : 	// 返回状态如果不设置，Ring3返回值是失败
; 139  : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

  00173	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  00176	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 140  : 	pIrp->IoStatus.Information = 0;

  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  00180	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 141  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  00187	32 d2		 xor	 dl, dl
  00189	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 142  : 	return STATUS_SUCCESS;

  00192	33 c0		 xor	 eax, eax

; 143  : }

  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
_IrpCreateProc@8 ENDP
; Function compile flags: /Odtp
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpCloseProc@8 PROC

; 147  : {

  001a0	55		 push	 ebp
  001a1	8b ec		 mov	 ebp, esp

; 148  : 	//DbgPrint("应用层断开连接设备.\n");
; 149  : 	// 返回状态如果不设置，Ring3返回值是失败
; 150  : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001a6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 151  : 	pIrp->IoStatus.Information = 0;

  001ad	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  001b0	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 152  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  001b7	32 d2		 xor	 dl, dl
  001b9	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 153  : 	return STATUS_SUCCESS;

  001c2	33 c0		 xor	 eax, eax

; 154  : }

  001c4	5d		 pop	 ebp
  001c5	c2 08 00	 ret	 8
_IrpCloseProc@8 ENDP
_TEXT	ENDS
PUBLIC	_PopApiCallQueue@8
PUBLIC	_SetIntGate@4
PUBLIC	_User32ApiSpyNaked@0
PUBLIC	_SetCallGate@8
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv70 = -44						; size = 4
_record$28423 = -40					; size = 4
_IntGateNum$28418 = -36					; size = 2
_nParam$28412 = -32					; size = 4
_pFunction$28411 = -28					; size = 4
_uIoControlCode$ = -24					; size = 4
_status$ = -20						; size = 4
_pIoBuffer$ = -16					; size = 4
_pIrpStack$ = -12					; size = 4
_uInLength$ = -8					; size = 4
_uOutLength$ = -4					; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_IrpDeviceControlProc@8 PROC

; 158  : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 159  : 	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

  001d6	c7 45 ec 10 00
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741808 ; c0000010H

; 160  : 	PIO_STACK_LOCATION pIrpStack;
; 161  : 	ULONG uIoControlCode;
; 162  : 	PVOID pIoBuffer;
; 163  : 	ULONG uInLength;
; 164  : 	ULONG uOutLength;
; 165  : 
; 166  : 	// 获取IRP数据
; 167  : 	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  001e6	89 45 f4	 mov	 DWORD PTR _pIrpStack$[ebp], eax

; 168  : 	// 获取控制码
; 169  : 	uIoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

  001e9	8b 4d f4	 mov	 ecx, DWORD PTR _pIrpStack$[ebp]
  001ec	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001ef	89 55 e8	 mov	 DWORD PTR _uIoControlCode$[ebp], edx

; 170  : 	// 获取缓冲区地址（输入输出是同一个）
; 171  : 	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

  001f2	8b 45 0c	 mov	 eax, DWORD PTR _pIrp$[ebp]
  001f5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001f8	89 4d f0	 mov	 DWORD PTR _pIoBuffer$[ebp], ecx

; 172  : 	// Ring3 发送数据的长度
; 173  : 	uInLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

  001fb	8b 55 f4	 mov	 edx, DWORD PTR _pIrpStack$[ebp]
  001fe	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00201	89 45 f8	 mov	 DWORD PTR _uInLength$[ebp], eax

; 174  : 	// Ring0 发送数据的长度
; 175  : 	uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  00204	8b 4d f4	 mov	 ecx, DWORD PTR _pIrpStack$[ebp]
  00207	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0020a	89 55 fc	 mov	 DWORD PTR _uOutLength$[ebp], edx

; 176  : 
; 177  : 	switch (uIoControlCode)

  0020d	8b 45 e8	 mov	 eax, DWORD PTR _uIoControlCode$[ebp]
  00210	89 45 d4	 mov	 DWORD PTR tv70[ebp], eax
  00213	81 7d d4 00 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236416 ; 00222000H
  0021a	74 17		 je	 SHORT $LN5@IrpDeviceC
  0021c	81 7d d4 04 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236420 ; 00222004H
  00223	74 45		 je	 SHORT $LN4@IrpDeviceC
  00225	81 7d d4 08 20
	22 00		 cmp	 DWORD PTR tv70[ebp], 2236424 ; 00222008H
  0022c	74 67		 je	 SHORT $LN3@IrpDeviceC
  0022e	e9 b6 00 00 00	 jmp	 $LN6@IrpDeviceC
$LN5@IrpDeviceC:

; 178  : 	{
; 179  : 	case OPER_CALL_GATE_R0:
; 180  : 		{
; 181  : 			UINT32 pFunction; // 3环函数指针
; 182  : 			UINT32 nParam; // 参数个数
; 183  : 			// 给3环传进来的函数指针设置一个调用门
; 184  : 			pFunction = ((PUINT32)pIoBuffer)[0];

  00233	8b 4d f0	 mov	 ecx, DWORD PTR _pIoBuffer$[ebp]
  00236	8b 11		 mov	 edx, DWORD PTR [ecx]
  00238	89 55 e4	 mov	 DWORD PTR _pFunction$28411[ebp], edx

; 185  : 			nParam = ((PUINT32)pIoBuffer)[1];

  0023b	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  0023e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00241	89 4d e0	 mov	 DWORD PTR _nParam$28412[ebp], ecx

; 186  : 			// 设置状态，返回数据
; 187  : 			((PUSHORT)pIoBuffer)[0] = SetCallGate(pFunction, nParam); // 返回调用门选择子

  00244	8b 55 e0	 mov	 edx, DWORD PTR _nParam$28412[ebp]
  00247	52		 push	 edx
  00248	8b 45 e4	 mov	 eax, DWORD PTR _pFunction$28411[ebp]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _SetCallGate@8
  00251	8b 4d f0	 mov	 ecx, DWORD PTR _pIoBuffer$[ebp]
  00254	66 89 01	 mov	 WORD PTR [ecx], ax

; 188  : 			pIrp->IoStatus.Information = 2; // 返回给3环的数据量

  00257	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  0025a	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 189  : 			status = STATUS_SUCCESS;

  00261	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 190  : 			break;

  00268	eb 7f		 jmp	 SHORT $LN6@IrpDeviceC
$LN4@IrpDeviceC:

; 191  : 		}
; 192  : 	case OPER_HOOK:
; 193  : 		{
; 194  : 			// 返回给3环的中断号，3环根据中断号HOOK API
; 195  : 			USHORT IntGateNum;
; 196  : 			// 构造提权中断门
; 197  : 			IntGateNum = SetIntGate((UINT32)User32ApiSpyNaked);

  0026a	68 00 00 00 00	 push	 OFFSET _User32ApiSpyNaked@0
  0026f	e8 00 00 00 00	 call	 _SetIntGate@4
  00274	66 89 45 dc	 mov	 WORD PTR _IntGateNum$28418[ebp], ax

; 198  : 			// 返回中断号
; 199  : 			*(PUSHORT)pIoBuffer = IntGateNum;

  00278	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  0027b	66 8b 4d dc	 mov	 cx, WORD PTR _IntGateNum$28418[ebp]
  0027f	66 89 08	 mov	 WORD PTR [eax], cx

; 200  : 			// 设置状态，返回数据
; 201  : 			pIrp->IoStatus.Information = 2; // 返回给3环的数据量

  00282	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  00285	c7 42 1c 02 00
	00 00		 mov	 DWORD PTR [edx+28], 2

; 202  : 			status = STATUS_SUCCESS;

  0028c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 203  : 			break;

  00293	eb 54		 jmp	 SHORT $LN6@IrpDeviceC
$LN3@IrpDeviceC:

; 204  : 		}
; 205  : 	case OPER_GET_APICALLRECORD:
; 206  : 		{
; 207  : 			PAPICALLRECORD record = NULL;

  00295	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _record$28423[ebp], 0

; 208  : 			PopApiCallQueue(&g_ApiCallRecordQueue, &record);

  0029c	8d 45 d8	 lea	 eax, DWORD PTR _record$28423[ebp]
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  002a5	e8 00 00 00 00	 call	 _PopApiCallQueue@8

; 209  : 			if (record == NULL)

  002aa	83 7d d8 00	 cmp	 DWORD PTR _record$28423[ebp], 0
  002ae	75 13		 jne	 SHORT $LN2@IrpDeviceC

; 210  : 			{
; 211  : 				// 设置状态，返回数据
; 212  : 				pIrp->IoStatus.Information = 0; // 返回给3环的数据量

  002b0	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002b3	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 213  : 				status = STATUS_SUCCESS;

  002ba	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 214  : 			}
; 215  : 			else

  002c1	eb 26		 jmp	 SHORT $LN6@IrpDeviceC
$LN2@IrpDeviceC:

; 216  : 			{
; 217  : 				memcpy(pIoBuffer, record, sizeof(APICALLRECORD));

  002c3	68 90 00 00 00	 push	 144			; 00000090H
  002c8	8b 55 d8	 mov	 edx, DWORD PTR _record$28423[ebp]
  002cb	52		 push	 edx
  002cc	8b 45 f0	 mov	 eax, DWORD PTR _pIoBuffer$[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 _memcpy
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 				// 设置状态，返回数据
; 219  : 				pIrp->IoStatus.Information = sizeof(APICALLRECORD); // 返回给3环的数据量

  002d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002db	c7 41 1c 90 00
	00 00		 mov	 DWORD PTR [ecx+28], 144	; 00000090H

; 220  : 				status = STATUS_SUCCESS;

  002e2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0
$LN6@IrpDeviceC:

; 221  : 			}
; 222  : 			break;
; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 	// 返回状态如果不设置，Ring3返回值是失败
; 227  : 	pIrp->IoStatus.Status = status;

  002e9	8b 55 0c	 mov	 edx, DWORD PTR _pIrp$[ebp]
  002ec	8b 45 ec	 mov	 eax, DWORD PTR _status$[ebp]
  002ef	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 228  : 	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  002f2	32 d2		 xor	 dl, dl
  002f4	8b 4d 0c	 mov	 ecx, DWORD PTR _pIrp$[ebp]
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 229  : 	return STATUS_SUCCESS;

  002fd	33 c0		 xor	 eax, eax

; 230  : }

  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c2 08 00	 ret	 8
_IrpDeviceControlProc@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@ ; `string'
PUBLIC	??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@ ; `string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@
; File d:\winddk\7600.16385.1\inc\ddk\wdm.h
_DATA	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@
_DATA	SEGMENT
??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@ DB 'D:\WinDD'
	DB	'K\7600.16385.1\inc\ddk\wdm.h', 00H		; `string'
; Function compile flags: /Odtp
_DATA	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00004	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00007	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000b	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0000e	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00012	83 c0 01	 add	 eax, 1
  00015	3b c8		 cmp	 ecx, eax
  00017	7e 20		 jle	 SHORT $LN3@IoGetCurre
  00019	6a 00		 push	 0
  0001b	68 15 5b 00 00	 push	 23317			; 00005b15H
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DDOEGKHI@D?3?2WinDDK?27600?416385?41?2inc?2ddk?2w@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00037	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  00039	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00043	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
; File c:\users\45819\documents\visual studio 2010\projects\msgboxawatcher\msgboxawatcher_ring0\msgboxawatcher_ring0.c
_TEXT	ENDS
_TEXT	SEGMENT
_IntGateLo$ = -32					; size = 4
_IntGateHi$ = -28					; size = 4
_IdtAddr$ = -24						; size = 4
_IdtLen$ = -20						; size = 4
_i$ = -16						; size = 4
_pPreIntGateAddr$ = -12					; size = 4
_IDT$ = -8						; size = 6
_pFuncion$ = 8						; size = 4
_SetIntGate@4 PROC

; 234  : {	

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	83 ec 20	 sub	 esp, 32			; 00000020H

; 235  : 	UCHAR IDT[6]; // IDT寄存器
; 236  : 	UINT32 IdtAddr,IdtLen;
; 237  : 	UINT32 IntGateHi = 0,IntGateLo = 0; // 中断门描述符

  00316	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _IntGateHi$[ebp], 0
  0031d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _IntGateLo$[ebp], 0

; 238  : 	UINT32 *pPreIntGateAddr = (UINT32*)g_pDevObj->DeviceExtension + 1;

  00324	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pDevObj
  00329	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0032c	83 c1 04	 add	 ecx, 4
  0032f	89 4d f4	 mov	 DWORD PTR _pPreIntGateAddr$[ebp], ecx

; 239  : 	UINT32 i;
; 240  : 	// 构造中断门描述符
; 241  : 	IntGateLo = ((pFuncion & 0x0000FFFF) | 0x00080000);

  00332	8b 55 08	 mov	 edx, DWORD PTR _pFuncion$[ebp]
  00335	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0033b	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00341	89 55 e0	 mov	 DWORD PTR _IntGateLo$[ebp], edx

; 242  : 	IntGateHi = ((pFuncion & 0xFFFF0000) | 0x0000EE00);

  00344	8b 45 08	 mov	 eax, DWORD PTR _pFuncion$[ebp]
  00347	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  0034c	0d 00 ee 00 00	 or	 eax, 60928		; 0000ee00H
  00351	89 45 e4	 mov	 DWORD PTR _IntGateHi$[ebp], eax

; 243  : 	// 遍历IDT，找无效项
; 244  : 	__asm
; 245  : 	{
; 246  : 		sidt fword ptr IDT;

  00354	0f 01 4d f8	 sidt	 FWORD PTR _IDT$[ebp]

; 247  : 	}
; 248  : 	IdtAddr = *(PULONG)(IDT+2);

  00358	8b 4d fa	 mov	 ecx, DWORD PTR _IDT$[ebp+2]
  0035b	89 4d e8	 mov	 DWORD PTR _IdtAddr$[ebp], ecx

; 249  : 	IdtLen = *(PUSHORT)IDT;

  0035e	0f b7 55 f8	 movzx	 edx, WORD PTR _IDT$[ebp]
  00362	89 55 ec	 mov	 DWORD PTR _IdtLen$[ebp], edx

; 250  : 	// 遍历IDT，找一个P=0的（跳过第一项）
; 251  : 	if ((*pPreIntGateAddr) == 0)

  00365	8b 45 f4	 mov	 eax, DWORD PTR _pPreIntGateAddr$[ebp]
  00368	83 38 00	 cmp	 DWORD PTR [eax], 0
  0036b	75 53		 jne	 SHORT $LN7@SetIntGate

; 252  : 	{				
; 253  : 		for (i = 8; i < IdtLen; i+=8)

  0036d	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
  00374	eb 09		 jmp	 SHORT $LN6@SetIntGate
$LN5@SetIntGate:
  00376	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00379	83 c1 08	 add	 ecx, 8
  0037c	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@SetIntGate:
  0037f	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00382	3b 55 ec	 cmp	 edx, DWORD PTR _IdtLen$[ebp]
  00385	73 37		 jae	 SHORT $LN4@SetIntGate

; 254  : 		{
; 255  : 			if ((((PUINT32)(IdtAddr + i))[1] & 0x00008000) == 0)

  00387	8b 45 e8	 mov	 eax, DWORD PTR _IdtAddr$[ebp]
  0038a	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  0038d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00390	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00396	75 24		 jne	 SHORT $LN3@SetIntGate

; 256  : 			{
; 257  : 				// P=0，此处GDT表项无效，可以使用
; 258  : 				((PUINT32)(IdtAddr + i))[0] = IntGateLo;

  00398	8b 55 e8	 mov	 edx, DWORD PTR _IdtAddr$[ebp]
  0039b	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  0039e	8b 45 e0	 mov	 eax, DWORD PTR _IntGateLo$[ebp]
  003a1	89 02		 mov	 DWORD PTR [edx], eax

; 259  : 				((PUINT32)(IdtAddr + i))[1] = IntGateHi;

  003a3	8b 4d e8	 mov	 ecx, DWORD PTR _IdtAddr$[ebp]
  003a6	03 4d f0	 add	 ecx, DWORD PTR _i$[ebp]
  003a9	8b 55 e4	 mov	 edx, DWORD PTR _IntGateHi$[ebp]
  003ac	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 260  : 				(*pPreIntGateAddr) = IdtAddr + i;				

  003af	8b 45 e8	 mov	 eax, DWORD PTR _IdtAddr$[ebp]
  003b2	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  003b5	8b 4d f4	 mov	 ecx, DWORD PTR _pPreIntGateAddr$[ebp]
  003b8	89 01		 mov	 DWORD PTR [ecx], eax

; 261  : 				break;

  003ba	eb 02		 jmp	 SHORT $LN4@SetIntGate
$LN3@SetIntGate:

; 262  : 			}
; 263  : 		}

  003bc	eb b8		 jmp	 SHORT $LN5@SetIntGate
$LN4@SetIntGate:

; 264  : 	}
; 265  : 	else

  003be	eb 15		 jmp	 SHORT $LN2@SetIntGate
$LN7@SetIntGate:

; 266  : 	{
; 267  : 		((PUINT32)(*pPreIntGateAddr))[0] = IntGateLo;

  003c0	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  003c3	8b 02		 mov	 eax, DWORD PTR [edx]
  003c5	8b 4d e0	 mov	 ecx, DWORD PTR _IntGateLo$[ebp]
  003c8	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 		((PUINT32)(*pPreIntGateAddr))[1] = IntGateHi;

  003ca	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  003cd	8b 02		 mov	 eax, DWORD PTR [edx]
  003cf	8b 4d e4	 mov	 ecx, DWORD PTR _IntGateHi$[ebp]
  003d2	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@SetIntGate:

; 269  : 	}
; 270  : 
; 271  : 	//DbgPrint("*pPreIntGateAddr: %p.\n", *pPreIntGateAddr);
; 272  : 	//DbgPrint("INT %02X\n", (USHORT)((*pPreIntGateAddr - IdtAddr) / 8));
; 273  : 	if (*pPreIntGateAddr == 0) return 0;

  003d5	8b 55 f4	 mov	 edx, DWORD PTR _pPreIntGateAddr$[ebp]
  003d8	83 3a 00	 cmp	 DWORD PTR [edx], 0
  003db	75 04		 jne	 SHORT $LN1@SetIntGate
  003dd	33 c0		 xor	 eax, eax
  003df	eb 0b		 jmp	 SHORT $LN8@SetIntGate
$LN1@SetIntGate:

; 274  : 	return (USHORT)((*pPreIntGateAddr - IdtAddr) / 8);

  003e1	8b 45 f4	 mov	 eax, DWORD PTR _pPreIntGateAddr$[ebp]
  003e4	8b 00		 mov	 eax, DWORD PTR [eax]
  003e6	2b 45 e8	 sub	 eax, DWORD PTR _IdtAddr$[ebp]
  003e9	c1 e8 03	 shr	 eax, 3
$LN8@SetIntGate:

; 275  : }

  003ec	8b e5		 mov	 esp, ebp
  003ee	5d		 pop	 ebp
  003ef	c2 04 00	 ret	 4
_SetIntGate@4 ENDP
; Function compile flags: /Odtp
_CallGateLo$ = -32					; size = 4
_pPreCallGateAddr$ = -28				; size = 4
_CallGateHi$ = -24					; size = 4
_GdtLen$ = -20						; size = 4
_GdtAddr$ = -16						; size = 4
_i$ = -12						; size = 4
_GDT$ = -8						; size = 6
_pFunction$ = 8						; size = 4
_nParam$ = 12						; size = 4
_SetCallGate@8 PROC

; 279  : {	

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	83 ec 20	 sub	 esp, 32			; 00000020H

; 280  : 	UINT32 CallGateHi = 0,CallGateLo = 0; // 调用门描述符

  00406	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _CallGateHi$[ebp], 0
  0040d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _CallGateLo$[ebp], 0

; 281  : 	UCHAR GDT[6]; // GDT寄存器
; 282  : 	UINT32 GdtAddr,GdtLen;
; 283  : 	UINT32 i;
; 284  : 	UINT32 *pPreCallGateAddr = (UINT32*)g_pDevObj->DeviceExtension;

  00414	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pDevObj
  00419	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0041c	89 4d e4	 mov	 DWORD PTR _pPreCallGateAddr$[ebp], ecx

; 285  : 
; 286  : 	// 构造调用门
; 287  : 	CallGateHi = (pFunction & 0xFFFF0000);

  0041f	8b 55 08	 mov	 edx, DWORD PTR _pFunction$[ebp]
  00422	81 e2 00 00 ff
	ff		 and	 edx, -65536		; ffff0000H
  00428	89 55 e8	 mov	 DWORD PTR _CallGateHi$[ebp], edx

; 288  : 	CallGateHi |= 0x0000EC00;

  0042b	8b 45 e8	 mov	 eax, DWORD PTR _CallGateHi$[ebp]
  0042e	0d 00 ec 00 00	 or	 eax, 60416		; 0000ec00H
  00433	89 45 e8	 mov	 DWORD PTR _CallGateHi$[ebp], eax

; 289  : 	CallGateHi |= nParam;

  00436	8b 4d e8	 mov	 ecx, DWORD PTR _CallGateHi$[ebp]
  00439	0b 4d 0c	 or	 ecx, DWORD PTR _nParam$[ebp]
  0043c	89 4d e8	 mov	 DWORD PTR _CallGateHi$[ebp], ecx

; 290  : 	CallGateLo = (pFunction & 0x0000FFFF);

  0043f	8b 55 08	 mov	 edx, DWORD PTR _pFunction$[ebp]
  00442	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00448	89 55 e0	 mov	 DWORD PTR _CallGateLo$[ebp], edx

; 291  : 	CallGateLo |= 0x00080000;

  0044b	8b 45 e0	 mov	 eax, DWORD PTR _CallGateLo$[ebp]
  0044e	0d 00 00 08 00	 or	 eax, 524288		; 00080000H
  00453	89 45 e0	 mov	 DWORD PTR _CallGateLo$[ebp], eax

; 292  : 	// 获取GDT基址和大小
; 293  : 	__asm
; 294  : 	{
; 295  : 		sgdt fword ptr GDT;

  00456	0f 01 45 f8	 sgdt	 FWORD PTR _GDT$[ebp]

; 296  : 	}
; 297  : 	GdtAddr = *(PULONG)(GDT+2);

  0045a	8b 4d fa	 mov	 ecx, DWORD PTR _GDT$[ebp+2]
  0045d	89 4d f0	 mov	 DWORD PTR _GdtAddr$[ebp], ecx

; 298  : 	GdtLen = *(PUSHORT)GDT;

  00460	0f b7 55 f8	 movzx	 edx, WORD PTR _GDT$[ebp]
  00464	89 55 ec	 mov	 DWORD PTR _GdtLen$[ebp], edx

; 299  : 	// 遍历GDT，找一个P=0的（跳过第一项）
; 300  : 	if ((*pPreCallGateAddr) == 0)

  00467	8b 45 e4	 mov	 eax, DWORD PTR _pPreCallGateAddr$[ebp]
  0046a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0046d	75 53		 jne	 SHORT $LN7@SetCallGat

; 301  : 	{				
; 302  : 		for (i = 8; i < GdtLen; i+=8)

  0046f	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
  00476	eb 09		 jmp	 SHORT $LN6@SetCallGat
$LN5@SetCallGat:
  00478	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0047b	83 c1 08	 add	 ecx, 8
  0047e	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@SetCallGat:
  00481	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00484	3b 55 ec	 cmp	 edx, DWORD PTR _GdtLen$[ebp]
  00487	73 37		 jae	 SHORT $LN4@SetCallGat

; 303  : 		{
; 304  : 			//DbgPrint("%p\n",(PUINT32)(GdtAddr + i));
; 305  : 			if ((((PUINT32)(GdtAddr + i))[1] & 0x00008000) == 0)

  00489	8b 45 f0	 mov	 eax, DWORD PTR _GdtAddr$[ebp]
  0048c	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  0048f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00492	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  00498	75 24		 jne	 SHORT $LN3@SetCallGat

; 306  : 			{
; 307  : 				// P=0，此处GDT表项无效，可以使用
; 308  : 				((PUINT32)(GdtAddr + i))[0] = CallGateLo;

  0049a	8b 55 f0	 mov	 edx, DWORD PTR _GdtAddr$[ebp]
  0049d	03 55 f4	 add	 edx, DWORD PTR _i$[ebp]
  004a0	8b 45 e0	 mov	 eax, DWORD PTR _CallGateLo$[ebp]
  004a3	89 02		 mov	 DWORD PTR [edx], eax

; 309  : 				((PUINT32)(GdtAddr + i))[1] = CallGateHi;

  004a5	8b 4d f0	 mov	 ecx, DWORD PTR _GdtAddr$[ebp]
  004a8	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  004ab	8b 55 e8	 mov	 edx, DWORD PTR _CallGateHi$[ebp]
  004ae	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 310  : 				(*pPreCallGateAddr) = GdtAddr + i;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR _GdtAddr$[ebp]
  004b4	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  004b7	8b 4d e4	 mov	 ecx, DWORD PTR _pPreCallGateAddr$[ebp]
  004ba	89 01		 mov	 DWORD PTR [ecx], eax

; 311  : 				break;

  004bc	eb 02		 jmp	 SHORT $LN4@SetCallGat
$LN3@SetCallGat:

; 312  : 			}
; 313  : 		}

  004be	eb b8		 jmp	 SHORT $LN5@SetCallGat
$LN4@SetCallGat:

; 314  : 	}
; 315  : 	else

  004c0	eb 15		 jmp	 SHORT $LN2@SetCallGat
$LN7@SetCallGat:

; 316  : 	{
; 317  : 		((PUINT32)(*pPreCallGateAddr))[0] = CallGateLo;

  004c2	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  004c5	8b 02		 mov	 eax, DWORD PTR [edx]
  004c7	8b 4d e0	 mov	 ecx, DWORD PTR _CallGateLo$[ebp]
  004ca	89 08		 mov	 DWORD PTR [eax], ecx

; 318  : 		((PUINT32)(*pPreCallGateAddr))[1] = CallGateHi;

  004cc	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  004cf	8b 02		 mov	 eax, DWORD PTR [edx]
  004d1	8b 4d e8	 mov	 ecx, DWORD PTR _CallGateHi$[ebp]
  004d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@SetCallGat:

; 319  : 	}
; 320  : 	if (*pPreCallGateAddr == 0) return 0;

  004d7	8b 55 e4	 mov	 edx, DWORD PTR _pPreCallGateAddr$[ebp]
  004da	83 3a 00	 cmp	 DWORD PTR [edx], 0
  004dd	75 04		 jne	 SHORT $LN1@SetCallGat
  004df	33 c0		 xor	 eax, eax
  004e1	eb 08		 jmp	 SHORT $LN8@SetCallGat
$LN1@SetCallGat:

; 321  : 	return (USHORT)((*pPreCallGateAddr) - GdtAddr);

  004e3	8b 45 e4	 mov	 eax, DWORD PTR _pPreCallGateAddr$[ebp]
  004e6	8b 00		 mov	 eax, DWORD PTR [eax]
  004e8	2b 45 f0	 sub	 eax, DWORD PTR _GdtAddr$[ebp]
$LN8@SetCallGat:

; 322  : }

  004eb	8b e5		 mov	 esp, ebp
  004ed	5d		 pop	 ebp
  004ee	c2 08 00	 ret	 8
_SetCallGate@8 ENDP
_TEXT	ENDS
PUBLIC	_GetPDE@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_GetPDE@4 PROC

; 326  : {

  00500	55		 push	 ebp
  00501	8b ec		 mov	 ebp, esp

; 327  : 	return (UINT32 *)(0xc0600000 + ((addr >> 18) & 0x3ff8));

  00503	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  00506	c1 e8 12	 shr	 eax, 18			; 00000012H
  00509	25 f8 3f 00 00	 and	 eax, 16376		; 00003ff8H
  0050e	2d 00 00 a0 3f	 sub	 eax, 1067450368		; 3fa00000H

; 328  : }

  00513	5d		 pop	 ebp
  00514	c2 04 00	 ret	 4
_GetPDE@4 ENDP
_TEXT	ENDS
PUBLIC	_GetPTE@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_GetPTE@4 PROC

; 332  : {

  00520	55		 push	 ebp
  00521	8b ec		 mov	 ebp, esp

; 333  : 	return (UINT32 *)(0xc0000000 + ((addr >> 9) & 0x7ffff8));

  00523	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  00526	c1 e8 09	 shr	 eax, 9
  00529	25 f8 ff 7f 00	 and	 eax, 8388600		; 007ffff8H
  0052e	2d 00 00 00 40	 sub	 eax, 1073741824		; 40000000H

; 334  : }

  00533	5d		 pop	 ebp
  00534	c2 04 00	 ret	 4
_GetPTE@4 ENDP
_TEXT	ENDS
PUBLIC	_User32ApiSpy@8
; Function compile flags: /Odtp
_TEXT	SEGMENT
_User32ApiSpyNaked@0 PROC

; 340  : 	__asm
; 341  : 	{
; 342  : 		pushad; // esp - 0x20

  00540	60		 pushad

; 343  : 		pushfd; // esp - 0x04

  00541	9c		 pushfd

; 344  : 
; 345  : 		mov eax,[esp + 0x24];		

  00542	8b 44 24 24	 mov	 eax, DWORD PTR [esp+36]

; 346  : 		mov ecx,[esp + 0x24 + 0x0C];

  00546	8b 4c 24 30	 mov	 ecx, DWORD PTR [esp+48]

; 347  : 		push eax; // EIP3

  0054a	50		 push	 eax

; 348  : 		push ecx; // ESP3

  0054b	51		 push	 ecx

; 349  : 		call User32ApiSpy;

  0054c	e8 00 00 00 00	 call	 _User32ApiSpy@8

; 350  : 
; 351  : 		popfd;

  00551	9d		 popfd

; 352  : 		popad;

  00552	61		 popad

; 353  : 		iretd;

  00553	cf		 iretd
_User32ApiSpyNaked@0 ENDP
_TEXT	ENDS
PUBLIC	_PushApiCallQueue@8
EXTRN	__imp__ExAllocatePool@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pApiCallRecord$28503 = -8				; size = 4
_ApiAddress$ = -4					; size = 4
_ESP3$ = 8						; size = 4
_EIP3$ = 12						; size = 4
_User32ApiSpy@8 PROC

; 359  : {

  00560	55		 push	 ebp
  00561	8b ec		 mov	 ebp, esp
  00563	83 ec 08	 sub	 esp, 8

; 360  : 	UINT32 ApiAddress;
; 361  : 	// EIP3-0x02是API的地址
; 362  : 	// ESP3是3环的ESP，可以用来读参数
; 363  : 	__asm push fs;

  00566	0f a0		 push	 fs

; 364  : 	ApiAddress = EIP3 - 2;

  00568	8b 45 0c	 mov	 eax, DWORD PTR _EIP3$[ebp]
  0056b	83 e8 02	 sub	 eax, 2
  0056e	89 45 fc	 mov	 DWORD PTR _ApiAddress$[ebp], eax

; 365  : 	//DbgPrint("ESP3: %08x, API: %08x\n", ESP3, ApiAddress);
; 366  : 	// 判断API地址
; 367  : 	if (ApiAddress == 0x77d507ea)

  00571	81 7d fc ea 07
	d5 77		 cmp	 DWORD PTR _ApiAddress$[ebp], 2010449898 ; 77d507eaH
  00578	75 68		 jne	 SHORT $LN1@User32ApiS

; 368  : 	{
; 369  : 		PAPICALLRECORD pApiCallRecord = NULL;

  0057a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pApiCallRecord$28503[ebp], 0

; 370  : 		// 添加调用记录到队列，监视进程通过IRP消息读取队列
; 371  : 		pApiCallRecord = (PAPICALLRECORD)ExAllocatePool(PagedPool,sizeof(APICALLRECORD));

  00581	68 90 00 00 00	 push	 144			; 00000090H
  00586	6a 01		 push	 1
  00588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePool@8
  0058e	89 45 f8	 mov	 DWORD PTR _pApiCallRecord$28503[ebp], eax

; 372  : 		pApiCallRecord->nParam = 4;

  00591	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  00594	c7 41 0c 04 00
	00 00		 mov	 DWORD PTR [ecx+12], 4

; 373  : 		pApiCallRecord->pApiAddress = ApiAddress;

  0059b	8b 55 f8	 mov	 edx, DWORD PTR _pApiCallRecord$28503[ebp]
  0059e	8b 45 fc	 mov	 eax, DWORD PTR _ApiAddress$[ebp]
  005a1	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 374  : 		pApiCallRecord->Param[0] = ((PUINT32)ESP3)[1];

  005a4	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  005a7	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  005aa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  005ad	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 375  : 		pApiCallRecord->Param[1] = ((PUINT32)ESP3)[2];

  005b0	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  005b3	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  005b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  005b9	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 376  : 		pApiCallRecord->Param[2] = ((PUINT32)ESP3)[3];

  005bc	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  005bf	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  005c2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  005c5	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 377  : 		pApiCallRecord->Param[3] = ((PUINT32)ESP3)[4];

  005c8	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  005cb	8b 55 08	 mov	 edx, DWORD PTR _ESP3$[ebp]
  005ce	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  005d1	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 378  : 		PushApiCallQueue(&g_ApiCallRecordQueue, (PAPICALLRECORD)pApiCallRecord);

  005d4	8b 4d f8	 mov	 ecx, DWORD PTR _pApiCallRecord$28503[ebp]
  005d7	51		 push	 ecx
  005d8	68 00 00 00 00	 push	 OFFSET _g_ApiCallRecordQueue
  005dd	e8 00 00 00 00	 call	 _PushApiCallQueue@8
$LN1@User32ApiS:

; 379  : 	}
; 380  : 	__asm pop fs;

  005e2	0f a1		 pop	 fs

; 381  : }

  005e4	8b e5		 mov	 esp, ebp
  005e6	5d		 pop	 ebp
  005e7	c2 08 00	 ret	 8
_User32ApiSpy@8 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_InitApiCallQueue@4 PROC

; 385  : {

  005f0	55		 push	 ebp
  005f1	8b ec		 mov	 ebp, esp

; 386  : 	QueueHead->ApiCallRecordList.Flink = QueueHead->ApiCallRecordList.Blink = (PLIST_ENTRY)QueueHead;

  005f3	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  005f6	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  005f9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  005fc	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  005ff	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00602	89 02		 mov	 DWORD PTR [edx], eax

; 387  : }

  00604	5d		 pop	 ebp
  00605	c2 04 00	 ret	 4
_InitApiCallQueue@4 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_pApiCallRecord$ = 12					; size = 4
_PushApiCallQueue@8 PROC

; 391  : {

  00610	55		 push	 ebp
  00611	8b ec		 mov	 ebp, esp

; 392  : 	// 原队尾的下一个节点指向新队尾
; 393  : 	QueueHead->ApiCallRecordList.Blink->Flink = (PLIST_ENTRY)pApiCallRecord;

  00613	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00616	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00619	8b 55 0c	 mov	 edx, DWORD PTR _pApiCallRecord$[ebp]
  0061c	89 11		 mov	 DWORD PTR [ecx], edx

; 394  : 	// 新队尾的上一个节点指向原队尾
; 395  : 	pApiCallRecord->ApiCallRecordList.Blink = QueueHead->ApiCallRecordList.Blink;

  0061e	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00621	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  00624	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00627	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 396  : 	// 新队尾的下一个节点指向队列头
; 397  : 	pApiCallRecord->ApiCallRecordList.Flink = (PLIST_ENTRY)QueueHead;

  0062a	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  0062d	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  00630	89 08		 mov	 DWORD PTR [eax], ecx

; 398  : 	// 队列头的上一个节点指向新队尾
; 399  : 	QueueHead->ApiCallRecordList.Blink = (PLIST_ENTRY)pApiCallRecord;	

  00632	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  00635	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00638	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 400  : }

  0063b	5d		 pop	 ebp
  0063c	c2 08 00	 ret	 8
_PushApiCallQueue@8 ENDP
; Function compile flags: /Odtp
_QueueHead$ = 8					; size = 4
_pApiCallRecord$ = 12					; size = 4
_PopApiCallQueue@8 PROC

; 404  : {

  00640	55		 push	 ebp
  00641	8b ec		 mov	 ebp, esp

; 405  : 	// 记录要弹出的节点
; 406  : 	*pApiCallRecord = (PAPICALLRECORD)(QueueHead->ApiCallRecordList.Flink);

  00643	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00646	8b 4d 08	 mov	 ecx, DWORD PTR _QueueHead$[ebp]
  00649	8b 11		 mov	 edx, DWORD PTR [ecx]
  0064b	89 10		 mov	 DWORD PTR [eax], edx

; 407  : 	// 如果队列为空，返回NULL
; 408  : 	if (*pApiCallRecord == &g_ApiCallRecordQueue)

  0064d	8b 45 0c	 mov	 eax, DWORD PTR _pApiCallRecord$[ebp]
  00650	81 38 00 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET _g_ApiCallRecordQueue
  00656	75 09		 jne	 SHORT $LN1@PopApiCall

; 409  : 	{
; 410  : 		*pApiCallRecord = NULL;

  00658	8b 4d 0c	 mov	 ecx, DWORD PTR _pApiCallRecord$[ebp]
  0065b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN1@PopApiCall:

; 411  : 	}
; 412  : 	// 第二个节点的上一个节点指向队首
; 413  : 	QueueHead->ApiCallRecordList.Flink->Flink->Blink = (PLIST_ENTRY)QueueHead;

  00661	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  00664	8b 02		 mov	 eax, DWORD PTR [edx]
  00666	8b 08		 mov	 ecx, DWORD PTR [eax]
  00668	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  0066b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 414  : 	// 队首的下一个节点指向第二个节点
; 415  : 	QueueHead->ApiCallRecordList.Flink = QueueHead->ApiCallRecordList.Flink->Flink;

  0066e	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00671	8b 08		 mov	 ecx, DWORD PTR [eax]
  00673	8b 55 08	 mov	 edx, DWORD PTR _QueueHead$[ebp]
  00676	8b 01		 mov	 eax, DWORD PTR [ecx]
  00678	89 02		 mov	 DWORD PTR [edx], eax

; 416  : }

  0067a	5d		 pop	 ebp
  0067b	c2 08 00	 ret	 8
_PopApiCallQueue@8 ENDP
_TEXT	ENDS
PUBLIC	_GetCountApiCallQueue@4
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pList$ = -8						; size = 4
_cnt$ = -4						; size = 4
_QueueHead$ = 8						; size = 4
_GetCountApiCallQueue@4 PROC

; 420  : {

  00680	55		 push	 ebp
  00681	8b ec		 mov	 ebp, esp
  00683	83 ec 08	 sub	 esp, 8

; 421  : 	UINT32 cnt = 0;

  00686	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0

; 422  : 	PLIST_ENTRY pList = QueueHead->ApiCallRecordList.Flink;

  0068d	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  00690	8b 08		 mov	 ecx, DWORD PTR [eax]
  00692	89 4d f8	 mov	 DWORD PTR _pList$[ebp], ecx
$LN2@GetCountAp:

; 423  : 	while (pList != (PLIST_ENTRY)QueueHead)

  00695	8b 55 f8	 mov	 edx, DWORD PTR _pList$[ebp]
  00698	3b 55 08	 cmp	 edx, DWORD PTR _QueueHead$[ebp]
  0069b	74 13		 je	 SHORT $LN1@GetCountAp

; 424  : 	{
; 425  : 		pList = pList->Flink;

  0069d	8b 45 f8	 mov	 eax, DWORD PTR _pList$[ebp]
  006a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  006a2	89 4d f8	 mov	 DWORD PTR _pList$[ebp], ecx

; 426  : 		cnt++;

  006a5	8b 55 fc	 mov	 edx, DWORD PTR _cnt$[ebp]
  006a8	83 c2 01	 add	 edx, 1
  006ab	89 55 fc	 mov	 DWORD PTR _cnt$[ebp], edx

; 427  : 	}

  006ae	eb e5		 jmp	 SHORT $LN2@GetCountAp
$LN1@GetCountAp:

; 428  : 	return cnt;

  006b0	8b 45 fc	 mov	 eax, DWORD PTR _cnt$[ebp]

; 429  : }

  006b3	8b e5		 mov	 esp, ebp
  006b5	5d		 pop	 ebp
  006b6	c2 04 00	 ret	 4
_GetCountApiCallQueue@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ExFreePoolWithTag@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pApiCallRecord$ = -4					; size = 4
_QueueHead$ = 8						; size = 4
_FreeApiCallQueue@4 PROC

; 433  : {

  006c0	55		 push	 ebp
  006c1	8b ec		 mov	 ebp, esp
  006c3	51		 push	 ecx
$LN2@FreeApiCal:

; 434  : 	PAPICALLRECORD pApiCallRecord;
; 435  : 	while(QueueHead->ApiCallRecordList.Flink != (PLIST_ENTRY)QueueHead)

  006c4	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  006c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  006c9	3b 4d 08	 cmp	 ecx, DWORD PTR _QueueHead$[ebp]
  006cc	74 1b		 je	 SHORT $LN3@FreeApiCal

; 436  : 	{		
; 437  : 		PopApiCallQueue(QueueHead, &pApiCallRecord);

  006ce	8d 55 fc	 lea	 edx, DWORD PTR _pApiCallRecord$[ebp]
  006d1	52		 push	 edx
  006d2	8b 45 08	 mov	 eax, DWORD PTR _QueueHead$[ebp]
  006d5	50		 push	 eax
  006d6	e8 00 00 00 00	 call	 _PopApiCallQueue@8

; 438  : 		ExFreePool(pApiCallRecord);

  006db	6a 00		 push	 0
  006dd	8b 4d fc	 mov	 ecx, DWORD PTR _pApiCallRecord$[ebp]
  006e0	51		 push	 ecx
  006e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePoolWithTag@8

; 439  : 	}

  006e7	eb db		 jmp	 SHORT $LN2@FreeApiCal
$LN3@FreeApiCal:

; 440  : }

  006e9	8b e5		 mov	 esp, ebp
  006eb	5d		 pop	 ebp
  006ec	c2 04 00	 ret	 4
_FreeApiCallQueue@4 ENDP
_TEXT	ENDS
END
